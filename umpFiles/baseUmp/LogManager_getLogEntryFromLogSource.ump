namespace com.sleepycat.je.log;

class LogManager_getLogEntryFromLogSource
{
  depend de.ovgu.cide.jakutil.*;
  depend com.sleepycat.je.utilint.Tracer;
  depend com.sleepycat.je.utilint.TestHook;
  depend com.sleepycat.je.utilint.DbLsn;
  depend com.sleepycat.je.utilint.Adler32;
  depend com.sleepycat.je.log.entry.LogEntry;
  depend com.sleepycat.je.dbi.EnvironmentImpl;
  depend com.sleepycat.je.dbi.DbConfigManager;
  depend com.sleepycat.je.config.EnvironmentParams;
  depend com.sleepycat.je.cleaner.UtilizationTracker;
  depend com.sleepycat.je.cleaner.TrackedFileSummary;
  depend com.sleepycat.je.RunRecoveryException;
  depend com.sleepycat.je.DatabaseException;
  depend java.util.zip.Checksum;
  depend java.util.List;
  depend java.nio.channels.ClosedChannelException;
  depend java.nio.ByteBuffer;
  depend java.nio.BufferOverflowException;
  depend java.io.RandomAccessFile;
  depend java.io.IOException;
    protected LogManager _this;

    protected long lsn;

    protected LogSource logSource;

    protected long fileOffset;

    protected ByteBuffer entryBuffer;

    protected long storedChecksum;

    protected byte loggableType;

    protected byte version;

    protected int itemSize;

    protected LogEntry logEntry;

    LogManager_getLogEntryFromLogSource(LogManager _this, long lsn, LogSource logSource) {
	this._this = _this;
	this.lsn = lsn;
	this.logSource = logSource;
    }

    LogEntry execute() throws DatabaseException {
	try {
	    fileOffset = DbLsn.getFileOffset(lsn);
	    entryBuffer = logSource.getBytes(fileOffset);
	    this.hook507();
	    loggableType = entryBuffer.get();
	    version = entryBuffer.get();
	    entryBuffer.position(entryBuffer.position() + _this.PREV_BYTES);
	    itemSize = LogUtils.readInt(entryBuffer);
	    if (entryBuffer.remaining() < itemSize) {
		entryBuffer = logSource.getBytes(fileOffset + _this.HEADER_BYTES, itemSize);
		this.hook508();
	    }
	    this.hook506();
	    assert LogEntryType.isValidType(loggableType) : "Read non-valid log entry type: " + loggableType;
	    logEntry = LogEntryType.findType(loggableType, version).getNewLogEntry();
	    logEntry.readEntry(entryBuffer, itemSize, version, true);
	    if (_this.readHook != null) {
		_this.readHook.doIOHook();
	    }
	    return logEntry;
	} catch (DatabaseException e) {
	    throw e;
	} catch (ClosedChannelException e) {
	    throw new RunRecoveryException(_this.envImpl, "Channel closed, may be " + "due to thread interrupt", e);
	} catch (Exception e) {
	    throw new DatabaseException(e);
	} finally {
	    if (logSource != null) {
		logSource.release();
	    }
	}
    }

    protected void hook506() throws DatabaseException, ClosedChannelException, Exception {
    }

    protected void hook507() throws DatabaseException, ClosedChannelException, Exception {
    }

    protected void hook508() throws DatabaseException, ClosedChannelException, Exception {
    }

}
