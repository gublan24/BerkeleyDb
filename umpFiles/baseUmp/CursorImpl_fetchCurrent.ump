namespace com.sleepycat.je.dbi;

class CursorImpl_fetchCurrent
{
  depend de.ovgu.cide.jakutil.*;
  depend com.sleepycat.je.utilint.TestHookExecute;
  depend com.sleepycat.je.utilint.TestHook;
  depend com.sleepycat.je.utilint.DbLsn;
  depend com.sleepycat.je.txn.ThreadLocker;
  depend com.sleepycat.je.txn.Locker;
  depend com.sleepycat.je.txn.LockType;
  depend com.sleepycat.je.txn.LockResult;
  depend com.sleepycat.je.txn.LockGrantType;
  depend com.sleepycat.je.txn.BasicLocker;
  depend com.sleepycat.je.tree.TreeWalkerStatsAccumulator;
  depend com.sleepycat.je.tree.Tree;
  depend com.sleepycat.je.tree.Node;
  depend com.sleepycat.je.tree.LN;
  depend com.sleepycat.je.tree.Key;
  depend com.sleepycat.je.tree.IN;
  depend com.sleepycat.je.tree.DupCountLN;
  depend com.sleepycat.je.tree.DIN;
  depend com.sleepycat.je.tree.DBIN;
  depend com.sleepycat.je.tree.BINBoundary;
  depend com.sleepycat.je.tree.BIN;
  depend com.sleepycat.je.log.LogUtils;
  depend com.sleepycat.je.RunRecoveryException;
  depend com.sleepycat.je.OperationStatus;
  depend com.sleepycat.je.LockStats;
  depend com.sleepycat.je.DatabaseException;
  depend com.sleepycat.je.DatabaseEntry;
  depend java.util.logging.Logger;
  depend java.util.logging.Level;
  depend java.util.Comparator;
    protected CursorImpl _this;

    protected DatabaseEntry foundKey;

    protected DatabaseEntry foundData;

    protected LockType lockType;

    protected boolean first;

    protected TreeWalkerStatsAccumulator treeStatsAccumulator;

    protected boolean duplicateFetch;

    protected Node n;

    protected EnvironmentImpl envImpl;

    protected DIN duplicateRoot;

    protected LN ln;

    protected LockResult lockResult;

    protected byte[] lnData;

    CursorImpl_fetchCurrent(CursorImpl _this, DatabaseEntry foundKey, DatabaseEntry foundData, LockType lockType,
	    boolean first) {
	this._this = _this;
	this.foundKey = foundKey;
	this.foundData = foundData;
	this.lockType = lockType;
	this.first = first;
    }

    OperationStatus execute() throws DatabaseException {
	try {
	    treeStatsAccumulator = _this.getTreeStatsAccumulator();
	    duplicateFetch = _this.setTargetBin();
	    if (_this.targetBin == null) {
		return OperationStatus.NOTFOUND;
	    }
	    this.hook259();
	    n = null;
	    if (_this.targetIndex < 0 || _this.targetIndex >= _this.targetBin.getNEntries()
		    || _this.targetBin.isEntryKnownDeleted(_this.targetIndex)) {
	    } else {
		if (_this.targetBin.isEntryPendingDeleted(_this.targetIndex)) {
		    this.hook280();
		}
		this.hook260();
	    }
	    if (n == null) {
		if (treeStatsAccumulator != null) {
		    treeStatsAccumulator.incrementDeletedLNCount();
		}
		this.hook261();
		return OperationStatus.KEYEMPTY;
	    }
	    _this.addCursor(_this.targetBin);
	    if (n.containsDuplicates()) {
		assert !duplicateFetch;
		duplicateRoot = (DIN) n;
		this.hook262();
		if (_this.positionFirstOrLast(first, duplicateRoot)) {
		    this.hook263();
		} else {
		    return OperationStatus.NOTFOUND;
		}
	    }
	    ln = (LN) n;
	    assert TestHookExecute.doHookIfSet(_this.testHook);
	    lockResult = _this.lockLN(ln, lockType);
	    this.hook258();
	    throw ReturnHack.returnObject;
	} catch (ReturnObject r) {
	    return (OperationStatus) r.value;
	}
    }

    protected void hook258() throws DatabaseException {
	ln = lockResult.getLN();
	lnData = (ln != null) ? ln.getData() : null;
	if (ln == null || lnData == null) {
	    if (treeStatsAccumulator != null) {
		treeStatsAccumulator.incrementDeletedLNCount();
	    }
	    throw new ReturnObject(OperationStatus.KEYEMPTY);
	}
	duplicateFetch = _this.setTargetBin();
	if (duplicateFetch) {
	    if (foundData != null) {
		_this.setDbt(foundData, _this.targetBin.getKey(_this.targetIndex));
	    }
	    if (foundKey != null) {
		_this.setDbt(foundKey, _this.targetBin.getDupKey());
	    }
	} else {
	    if (foundData != null) {
		_this.setDbt(foundData, lnData);
	    }
	    if (foundKey != null) {
		_this.setDbt(foundKey, _this.targetBin.getKey(_this.targetIndex));
	    }
	}
	throw new ReturnObject(OperationStatus.SUCCESS);
    }

    protected void hook259() throws DatabaseException {
    }

    protected void hook260() throws DatabaseException {
	n = _this.targetBin.fetchTarget(_this.targetIndex);
    }

    protected void hook261() throws DatabaseException {
    }

    protected void hook262() throws DatabaseException {
    }

    protected void hook263() throws DatabaseException {
	throw new ReturnObject(_this.fetchCurrent(foundKey, foundData, lockType, first));
    }

    protected void hook280() throws DatabaseException {
    }

}
