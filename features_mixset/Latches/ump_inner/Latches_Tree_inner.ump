// //original file:/home/abdulaziz/Desktop/BerkeleyDb/ALL_FEATURE/features/Latches/com/sleepycat/je/tree/Tree.java
namespace com.sleepycat.je.tree;
class Tree {
   static class Tree_forceSplit {
      after Label722: execute()   {
        isRootLatched=false;
        //original();
      }
      after Label723:execute()   {
        if (origParent.isDbRoot()) {
          _this.rootLatch.acquireExclusive();
          isRootLatched=true;
        }
        origParent.latch();
        //original();
      }
      after Label724:execute()    {
        child.latch();
        //original();
      }
      after Label725: execute()    {
        child.releaseLatch();
        //original();
      }
      after Label726:execute()    {
        assert isRootLatched;
        //original();
      }
      after Label727: execute()   {
        if (!success) {
          if (child != null) {
            child.releaseLatchIfOwner();
          }
          origParent.releaseLatchIfOwner();
        }
        if (nodeLadder.size() > 0) {
          iter=nodeLadder.listIterator(nodeLadder.size());
          while (iter.hasPrevious()) {
            info2=(SplitInfo)iter.previous();
            info2.child.releaseLatchIfOwner();
          }
        }
        if (isRootLatched) {
          _this.rootLatch.release();
        }
        //original();
      }
    }
   static class Tree_searchSplitsAllowed {
      after Label716_1:execute()   {
          if (rootLatched) {
            _this.rootLatch.release();
          }
        
      }
      after Label717:execute()    {
        _this.rootLatch.acquireShared();
        rootLatched=true;
        rootLatchedExclusive=false;
        //original();
      }
      after Label718:execute()    {
        rootIN.latch();
        //original();
      }
      after Label719:execute()    {
        rootLatched=true;
        _this.rootLatch.acquireExclusive();
        //original();
      }
      after Label720:execute()    {
        _this.splitRoot();
        _this.rootLatch.release();
        rootLatched=false;
        //original();
      }
      after Label721:execute()    {
        b=!rootLatchedExclusive;
        if (b) {
          rootIN=null;
          _this.rootLatch.release();
          _this.rootLatch.acquireExclusive();
          rootLatchedExclusive=true;
        }
        //original();
      }
    }
  inner class RootChildReference {
      after Label666: fetchTarget(    DatabaseImpl ,    IN )   {
        if (getTarget() == null && !rootLatch.isWriteLockedByCurrentThread()) {
          rootLatch.release();
          rootLatch.acquireExclusive();
        }
        //original();
      }
      after Label667: setTarget(    Node target){
        assert rootLatch.isWriteLockedByCurrentThread();
        //original();
      }
      after Label668: clearTarget(){
        assert rootLatch.isWriteLockedByCurrentThread();
        //original();
      }
      after Label669: setLsn(    long ){
        assert rootLatch.isWriteLockedByCurrentThread();
        //original();
      }
    }
}




     public Node fetchTarget(    DatabaseImpl database,    IN in) throws DatabaseException {
        Label666:           ;  //this.hook666();
        return super.fetchTarget(database,in);
      }
      public void setTarget(    Node target){
        Label667:           ;  //this.hook667();
        super.setTarget(target);
      }
      public void clearTarget(){
        Label668:           ;  //this.hook668();
        super.clearTarget();
      }
      public void setLsn(    long lsn){
        Label669:           ;  //this.hook669();
        super.setLsn(lsn);
      }
