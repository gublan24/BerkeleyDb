// //original file:/home/abdulaziz/Desktop/BerkeleyDb/ALL_FEATURE/features/Latches/com/sleepycat/je/tree/Tree.java
namespace com.sleepycat.je.tree;
class Tree {

   static class Tree_forceSplit {
      after Label722: execute()   {
        isRootLatched=false;
        //original();
      }

      after Label723:execute()   {
        if (origParent.isDbRoot()) {
          _this.rootLatch.acquireExclusive();
          isRootLatched=true;
        }
        origParent.latch();
        //original();
      }

      after Label724:execute()    {
        child.latch();
        //original();
      }

      after Label725: execute()    {
        child.releaseLatch();
        //original();
      }

      after Label726:execute()    {
        assert isRootLatched;
        //original();
      }

      after Label727: execute()   {
        if (!success) {
          if (child != null) {
            child.releaseLatchIfOwner();
          }
          origParent.releaseLatchIfOwner();
        }
        if (nodeLadder.size() > 0) {
          iter=nodeLadder.listIterator(nodeLadder.size());
          while (iter.hasPrevious()) {
            info2=(SplitInfo)iter.previous();
            info2.child.releaseLatchIfOwner();
          }
        }
        if (isRootLatched) {
          _this.rootLatch.release();
        }
        //original();
      }
    }

   static class Tree_searchSplitsAllowed {
      after Label716_1:execute()   {
          if (rootLatched) {
            _this.rootLatch.release();
          }
        
      }
      after Label717:execute()    {
        _this.rootLatch.acquireShared();
        rootLatched=true;
        rootLatchedExclusive=false;
        //original();
      }

      after Label718:execute()    {
        rootIN.latch();
        //original();
      }

      after Label719:execute()    {
        rootLatched=true;
        _this.rootLatch.acquireExclusive();
        //original();
      }

      after Label720:execute()    {
        _this.splitRoot();
        _this.rootLatch.release();
        rootLatched=false;
        //original();
      }

      after Label721:execute()    {
        b=!rootLatchedExclusive;
        if (b) {
          rootIN=null;
          _this.rootLatch.release();
          _this.rootLatch.acquireExclusive();
          rootLatchedExclusive=true;
        }
        //original();
      }
    }


  inner class RootChildReference {

      after Label666: fetchTarget(    DatabaseImpl ,    IN )   {
        if (getTarget() == null && !rootLatch.isWriteLockedByCurrentThread()) {
          rootLatch.release();
          rootLatch.acquireExclusive();
        }
        //original();
      }
      after Label667: setTarget(    Node ){
        assert rootLatch.isWriteLockedByCurrentThread();
        //original();
      }
      after Label668: clearTarget(){
        assert rootLatch.isWriteLockedByCurrentThread();
        //original();
      }
      after Label669: setLsn(    long ){
        assert rootLatch.isWriteLockedByCurrentThread();
        //original();
      }
    }
}





