// //original file:/home/abdulaziz/Desktop/BerkeleyDb/ALL_FEATURE/features/Latches/com/sleepycat/je/dbi/CursorImpl.java
namespace com.sleepycat.je.dbi;

class CursorImpl {
    static class CursorImpl_latchBIN {
        after Label244: execute() {
            while (_this.bin != null) {
                waitingOn = _this.bin;
                waitingOn.latch();
                if (_this.bin == waitingOn) {
                    return _this.bin; 
                }
                waitingOn.releaseLatch();
            }
        }

    }
    static class CursorImpl_getNextDuplicate {

        after Label250: execute() {
            assert _this.checkAlreadyLatched(alreadyLatched): _this.dumpToString(true);
            //original();
        }

        after Label251: execute() {
            if (!alreadyLatched) {
                _this.latchDBIN();
            } else {
                alreadyLatched = false;
            }
            //original();
        }
        after Label252: execute() {
            _this.releaseDBIN();
            //original();
        }
        after Label253: execute() {
            assert LatchSupport.countLatchesHeld() == 0;
            //original();
        }
        after Label254: execute() {

            assert(LatchSupport.countLatchesHeld() == 0);
            _this.dupBinToBeRemoved.latch();
            //original();
        }
        after Label255: execute() {
            _this.dupBinToBeRemoved.releaseLatch();
            //original();
        }
        after Label256: execute() {

            alreadyLatched = true;
            //original();
        }
        after Label257: execute() {
            assert LatchSupport.countLatchesHeld() == 0;
            //original();
        }
    }
    static class CursorImpl_lockNextKeyForInsert {
        around Label248-Label248_1: execute() {
            latched = true;
            try {
                around_proceed:
            }
            finally {
                if (latched) {
                    _this.releaseBINs();
                }
            }
        }
        after Label249: execute() {
            latched = false;
            //original();
        }
    }
    static class CursorImpl_latchDBIN {
 
      strictness disable constructor;  

        after Label246: execute() {
            
            while (_this.dupBin != null) 
            {
              waitingOn = _this.dupBin;
              waitingOn.latch();
              if (_this.dupBin == waitingOn) 
              {
                return _this.dupBin;
              }
              waitingOn.releaseLatch();
               
            }

       }

   
    }
    static class CursorImpl_fetchCurrent {

        around Label258-Label258_1: execute() {
            try {
                around_proceed: //original();
            }
            finally {
                _this.releaseBINs();
            }
        }

        after Label259: execute() {
            assert _this.targetBin.isLatchOwner();
            //original();
        }

        around Label260-Label260_1: execute() {
            try {
                around_proceed: //original();
            }
            catch (DatabaseException DE) {
                _this.targetBin.releaseLatchIfOwner();
                throw DE;
            }
        }
        after Label261: execute() {
            _this.targetBin.releaseLatchIfOwner();
            //original();
        }
        after Label262: execute() {
            duplicateRoot.latch();
            _this.targetBin.releaseLatch();
            //original();
        }
        around Label263-Label263_1: execute() {
            try {
                around_proceed: //original();
            }
            catch (DatabaseException DE) {
                _this.releaseBINs();
                throw DE;
            }
        }
    }
}
