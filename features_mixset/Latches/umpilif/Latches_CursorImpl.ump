namespace com.sleepycat.je.dbi;

class CursorImpl {
    depend com.sleepycat.je.latch.LatchSupport;
    depend com.sleepycat.je.latch.LatchNotHeldException;
    public void releaseBIN() throws LatchNotHeldException {
        if (bin != null) {
            bin.releaseLatchIfOwner();
        }
    }

    public void latchBINs() throws DatabaseException {
        latchBIN();
        latchDBIN();
    }

    public void releaseBINs() throws LatchNotHeldException {
        releaseBIN();
        releaseDBIN();
    }

    public void releaseDBIN() throws LatchNotHeldException {
        if (dupBin != null) {
            dupBin.releaseLatchIfOwner();
        }
    }

    private boolean checkAlreadyLatched(boolean alreadyLatched) {
        if (alreadyLatched) {
            if (dupBin != null) {
                return dupBin.isLatchOwner();
            } else if (bin != null) {
                return bin.isLatchOwner();
            }
        }
        return true;
    }

    after Label206:  cloneCursor(boolean , CursorImpl ){

        latchBINs();
        //original();
    }

    after Label207:  cloneCursor(boolean , CursorImpl ) {
        releaseBINs();
        //original();
    }

    after Label208:  addCursor(BIN ) {

        assert bin.isLatchOwner();
        //original(bin);
    }

    after Label209: removeCursorBIN()  {
        abin.releaseLatch();
        //original(abin);
    }

    after Label210: removeCursorDBIN() {
        abin.releaseLatch();
        //original(abin);
    }

    after Label211: clearDupBIN(boolean ) {
        dupBin.releaseLatch();
        //original();
    }

		before  count(LockType)
		{
				    latchBIN();
		}

    after Label212: {
     //   latchBIN();
 //       try {
            //original(lockType);
  //      } finally {
            releaseBIN();
   //     }
    }

    after Label213_1: delete() {

        //try {original(isDup, ln, lockResult, dclLockResult, dupRoot);} finally {

            if (dupRoot != null) {
                dupRoot.releaseLatchIfOwner();
            }
      //  }
    }

    after Label214: delete() {


        releaseBINs();
        //original();
    }

    after Label215: delete() {

        releaseBINs();
        //original();
    }

    after Label216:  delete() {
        releaseBINs();
        //original();
    }

    after Label217: putLN(byte, LN , boolean ) { 
        assert LatchSupport.countLatchesHeld() == 0;
        //original();
    }

    after Label218_1: putCurrent(DatabaseEntry , DatabaseEntry , DatabaseEntry ) {
    //    try {
            //original(data, foundKey, foundData, isDup);
      //  } finally {
            releaseBINs();
        //}
    }

    after Label219: putCurrent(DatabaseEntry , DatabaseEntry , DatabaseEntry ) {

        latchBINs();
        //original();
    }

    after Label220: getCurrent(DatabaseEntry , DatabaseEntry , LockType ){
        if (dupBin == null) {
            latchBIN();
        } else {
            latchDBIN();
        }
        //original();
    }

    after Label221: getCurrentAlreadyLatched(DatabaseEntry , DatabaseEntry , LockType ,        boolean ){
        assert checkAlreadyLatched(true): dumpToString(true);
        try {
                    throw new ReturnObject(fetchCurrent(foundKey, foundData, lockType, first));
										//original(foundKey, foundData, lockType, first);
        } finally {
            releaseBINs();
        }
    }

    after Label222:getCurrentLN(LockType ){
        latchBIN();
        //original();
    }

    after Label223_1: getCurrentLNAlreadyLatched(LockType ) {

       // try {
            //original(lockType);
        //} finally {
            releaseBINs();
        //}
    }

    after Label224: getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        assert checkAlreadyLatched(alreadyLatched): dumpToString(true);
        //original(alreadyLatched);
    }

    protected boolean hook225: getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        assert checkAlreadyLatched(alreadyLatched): dumpToString(true);
        if (!alreadyLatched) {
            latchBIN();
        } else {
            alreadyLatched = false;
        }
        return //original(alreadyLatched);
    }

    protected boolean hook226:  getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        alreadyLatched = false;
        return //original(alreadyLatched);
    }

    after Label227:getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        assert LatchSupport.countLatchesHeld() == 0;
        //original();
    }

    after Label228: getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        latchBIN();
        //original();
    }

    after Label229: getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        releaseBIN();
        //original();
    }

    after Label230: getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        alreadyLatched = true;
        //original(alreadyLatched);
    }

    after Label231: getNextWithKeyChangeStatus(DatabaseEntry , DatabaseEntry ,LockType , boolean, boolean ) {
        assert LatchSupport.countLatchesHeld() == 0: LatchSupport.latchesHeldToString();
        //original();
    }

    before flushBINToBeRemoved() {

        binToBeRemoved.latch();
        //original();
    }

    after Label232:flushBINToBeRemoved() {
        binToBeRemoved.releaseLatch();
        //original();
    }

    before flushDBINToBeRemoved() {
        dupBinToBeRemoved.latch();
        //original();
    }

    after Label233: flushDBINToBeRemoved(){
        dupBinToBeRemoved.releaseLatch();
        //original();
    }

    after Label234_1: positionFirstOrLast(boolean , DIN ) {
        //try {
            //original(first, duplicateRoot, in, found);
       // } 
       catch (DatabaseException e) {
            if ( in != null) 
            { in .releaseLatch();
            }
            throw e;
        }
    }

    after Label235_1:searchAndPosition(DatabaseEntry , DatabaseEntry , SearchMode ,        LockType ) {

        //try {
            //original(matchKey, matchData, searchMode, lockType, foundSomething, foundExactKey, foundExactData, foundLast,            exactSearch,            binBoundary);
//    } 
catch (DatabaseException e) {
        releaseBIN();
        throw e;
    }
}

after Label236: searchAndPositionBoth(boolean , Node , DatabaseEntry , boolean , LockType , long ){
    duplicateRoot.latch();
    releaseBIN();
    //original(duplicateRoot);
}

after Label237: lockLNDeletedAllowed(LN , LockType )  {
    latchBINs();
    //original();
}

after Label238: lockLNDeletedAllowed(LN , LockType )  {
    releaseBINs();
    //original();
}

after Label239: lockDupCountLN(DIN , LockType )  {
    dupRoot.latch();
    latchDBIN();
    //original(dupRoot);
}

after Label240: lockDupCountLN(DIN , LockType )  {

    latchBIN();
    //original();
}

after Label241: lockDupCountLN(DIN , LockType )  {
    dupRoot.releaseLatch();
    releaseBINs();
    //original(dupRoot);
}

after Label242: getLatchedDupRoot(boolean ){

    if (isDBINLatched) {
        if (!dupRoot.latchNoWait()) {
            releaseDBIN();
            dupRoot.latch();
            latchDBIN();
        }
    } else {
        dupRoot.latch();
    }
    //original(isDBINLatched, dupRoot);
}

after Label243: getLatchedDupRoot(boolean ){
    assert bin.isLatchOwner();
    //original();
}

after Label264: count(LockType ) {
    dupRoot.releaseLatch();
    //original(dupRoot);
}

after Label265: count(LockType ) {

    dupRoot.latch();
    releaseBIN();
    //original(dupRoot);
}

after Label266: delete() {
    releaseBINs();
    //original();
}

after Label267:: delete() {
    releaseBIN();
    //original();
}

after Label268: delete() {
    dupRoot.releaseLatch();
    //original(dupRoot);
}

after Label269:putCurrent(DatabaseEntry , DatabaseEntry , DatabaseEntry ) {
    releaseBINs();
    //original();
}

after Label270: putCurrent(DatabaseEntry , DatabaseEntry , DatabaseEntry ) {
    releaseBINs();
    //original();
}

after Label271: putCurrent(DatabaseEntry , DatabaseEntry , DatabaseEntry ) {
    releaseBINs();
    //original();
}

after Label272:  getCurrentLNAlreadyLatched(LockType ) {
    assert checkAlreadyLatched(true): dumpToString(true);
    //original();
}

after Label273:  getCurrentLNAlreadyLatched(LockType ) {
    releaseBIN();
    //original();
}

after Label274: positionFirstOrLast(boolean , DIN ){
    dupRoot.latch(); in .releaseLatch();
    //original(in, dupRoot);
}

}
