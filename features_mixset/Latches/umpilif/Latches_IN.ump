namespace com.sleepycat.je.tree;

class IN
{
  depend com.sleepycat.je.latch.LatchSupport;
  depend com.sleepycat.je.latch.LatchNotHeldException;
  depend com.sleepycat.je.latch.Latch;
    private Latch latch;

    /** 
     * Latch this node and set the generation.
     */
    public void latch() throws DatabaseException {
	latch(true);
    }

    /** 
     * Latch this node if it is not latched by another thread, and set the generation if the latch succeeds.
     */
    public boolean latchNoWait() throws DatabaseException {
	return latchNoWait(true);
    }

    /** 
     * Release the latch on this node.
     */
    public void releaseLatch() throws LatchNotHeldException {
	latch.release();
    }

    /** 
     * Release the latch on this node.
     */
    public void releaseLatchIfOwner() throws LatchNotHeldException {
	latch.releaseIfOwner();
    }

    /** 
     * @return true if this thread holds the IN's latch
     */
    public boolean isLatchOwner() {
	return latch.isOwner();
    }

    protected void hook618: init(DatabaseImpl , byte , int , int ) {
	latch = LatchSupport.makeLatch(shortClassName() + getNodeId(), env);
	//original(env);
    }

    /** 
     * Latch this node, optionally setting the generation.
     */
    after latch(boolean ) {

	//original(updateGeneration);
	latch.acquire();
    }

  after Label619: latchNoWait(boolean ){
      if (! latch.acquireExclusiveNoWait()) {
            return false;
      }
  }

    /** 
     * See if you are the parent of this child. If not, find a child of your's that may be the parent, and return it. If there are no possiblities, return null. Note that the keys of the target are passed in so we don't have to latch the target to look at them. Also, this node is latched upon entry.
     * @param doFetch If true, fetch the child in the pursuit of this search.If false, give up if the child is not resident. In that case, we have a potential ancestor, but are not sure if this is the parent.
     */


    before findParent(Tree.SearchType , long , boolean , boolean , byte, byte, SearchResult ,	boolean , boolean , int , List , boolean ) {
	assert isLatchOwner();
	//original(searchType, targetNodeId, targetContainsDuplicates, targetIsRoot, targetMainTreeKey, targetDupTreeKey,result, requireExactMatch, updateGeneration, targetLevel, trackingList, doFetch);
    }

    protected void hook620: findParent(Tree.SearchType , long , boolean , boolean , byte , byte , SearchResult , boolean , boolean , int , List , boolean ) {
	releaseLatch();
	//original();
    }

    protected void hook621: findParent(Tree.SearchType , long , boolean , boolean , byte , byte , SearchResult , boolean , boolean , int , List , boolean ) {
	releaseLatch();
	//original();
    }

    protected void hook622: findParent(Tree.SearchType , long , boolean , boolean , byte , byte , SearchResult , boolean , boolean , int , List , boolean ) {
	releaseLatch();
	//original();
    }

    protected void hook623: findParent(Tree.SearchType , long , boolean , boolean , byte , byte , SearchResult , boolean , boolean , int , List , boolean ) {
	releaseLatch();
	//original();
    }

    protected void hook624:  descendOnParentSearch(SearchResult , boolean , boolean , long , Node , boolean ) {

	releaseLatch();
	//original();
    }

    protected void hook625:  descendOnParentSearch(SearchResult , boolean , boolean , long , Node , boolean ) {

	((IN) child).releaseLatch();
	//original(child);
    }

    protected void hook626:  descendOnParentSearch(SearchResult , boolean , boolean , long , Node , boolean ) {
	releaseLatch();
	//original();
    }

    protected void hook627: isSoughtNode(long , boolean ){
	releaseLatch();
	//original();
    }

    /** 
     * @see LogReadable#readFromLog
     */
    after readFromLog(ByteBuffer , byte ) {

	//original(itemBuffer, entryTypeVersion);
	latch.setName(shortClassName() + getNodeId());
    }

}
