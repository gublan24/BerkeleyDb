// Original file:/home/abdulaziz/Desktop/BerkeleyDb/javaFiles/base_x/com/sleepycat/je/tree/IN.java
namespace com.sleepycat.je.tree;
class IN {
  @MethodObject static class IN_setLsn {
      IN_setLsn(    IN _this,    int idx,    long lsn){
        this._this=_this;
        this.idx=idx;
        this.lsn=lsn;
      }
      void execute(){
        _this.setLsnElement(idx,lsn);
        //this.hook639();
        Label639:
        _this.entryStates[idx]|=_this.DIRTY_BIT;
      }
      protected IN _this;
      protected int idx;
      protected long lsn;
      protected int oldSize;
      protected void hook639(){
      }
    }
  @MethodObject static class IN_setEntry {
      IN_setEntry(    IN _this,    int idx,    Node target,    byte[] keyVal,    long lsn,    byte state){
        this._this=_this;
        this.idx=idx;
        this.target=target;
        this.keyVal=keyVal;
        this.lsn=lsn;
        this.state=state;
      }
      void execute(){
        newNEntries=idx + 1;
        if (newNEntries > _this.nEntries) {
          _this.nEntries=newNEntries;
          //this.hook641();
          Label641:
        }
        _this.entryTargets[idx]=target;
        _this.entryKeyVals[idx]=keyVal;
        _this.setLsnElement(idx,lsn);
        _this.entryStates[idx]=state;
        //this.hook640();
        Label640:
        _this.setDirty(true);
      }
      protected IN _this;
      protected int idx;
      protected Node target;
      protected byte[] keyVal;
      protected long lsn;
      protected byte state;
      protected long oldSize;
      protected int newNEntries;
      protected long newSize;
      protected void hook640(){
      }
      //protected void hook641(){
      //}
    }
  @MethodObject static class IN_updateEntry {
      IN_updateEntry(    IN _this,    int idx,    Node node){
        this._this=_this;
        this.idx=idx;
        this.node=node;
      }
      void execute(){
        _this.setTarget(idx,node);
      }
      protected IN _this;
      protected int idx;
      protected Node node;
      protected long oldSize;
      protected long newSize;
    }
  @MethodObject static class IN_updateEntry2 {
      IN_updateEntry2(    IN _this,    int idx,    Node node,    long lsn){
        this._this=_this;
        this.idx=idx;
        this.node=node;
        this.lsn=lsn;
      }
      void execute(){
        _this.setLsn(idx,lsn);
        _this.setTarget(idx,node);
        //this.hook642();
        Label642:
        _this.setDirty(true);
      }
      protected IN _this;
      protected int idx;
      protected Node node;
      protected long lsn;
      protected long oldSize;
      protected long newSize;
      protected void hook642(){
      }
    }
  @MethodObject static class IN_updateEntry3 {
      IN_updateEntry3(    IN _this,    int idx,    Node node,    long lsn,    byte[] key){
        this._this=_this;
        this.idx=idx;
        this.node=node;
        this.lsn=lsn;
        this.key=key;
      }
      void execute(){
        _this.setLsn(idx,lsn);
        _this.setTarget(idx,node);
        _this.setKey(idx,key);
        //this.hook643();
        Label643:
        _this.setDirty(true);
      }
      protected IN _this;
      protected int idx;
      protected Node node;
      protected long lsn;
      protected byte[] key;
      protected long oldSize;
      protected long newSize;
      protected void hook643(){
      }
    }
  @MethodObject static class IN_updateEntryCompareKey {
      IN_updateEntryCompareKey(    IN _this,    int idx,    Node node,    long lsn,    byte[] key){
        this._this=_this;
        this.idx=idx;
        this.node=node;
        this.lsn=lsn;
        this.key=key;
      }
      void execute(){
        _this.setLsn(idx,lsn);
        _this.setTarget(idx,node);
        existingKey=_this.getKey(idx);
        s=Key.compareKeys(key,existingKey,_this.getKeyComparator());
        if (s < 0) {
          _this.setKey(idx,key);
        }
        //this.hook644();
       Label644:
        _this.setDirty(true);
      }
      protected IN _this;
      protected int idx;
      protected Node node;
      protected long lsn;
      protected byte[] key;
      protected long oldSize;
      protected byte[] existingKey;
      protected int s;
      protected long newSize;
     // protected void hook644(){
     // }
    }
  @MethodObject static class IN_insertEntry1 {
      IN_insertEntry1(    IN _this,    ChildReference entry){
        this._this=_this;
        this.entry=entry;
      }
      int execute() throws DatabaseException {
        if (_this.nEntries >= _this.entryTargets.length) {
          _this.compress(null,true);
        }
        if (_this.nEntries < _this.entryTargets.length) {
          key=entry.getKey();
          index=_this.findEntry(key,true,false);
          if (index >= 0 && (index & _this.EXACT_MATCH) != 0) {
            return index;
          }
   else {
            index++;
          }
          if (index < _this.nEntries) {
            //this.hook647();
            Label647:
            _this.shiftEntriesRight(index);
            //this.hook646();
            Label646:
          }
          _this.entryTargets[index]=entry.getTarget();
          _this.entryKeyVals[index]=entry.getKey();
          _this.setLsnElement(index,entry.getLsn());
          _this.entryStates[index]=entry.getState();
          _this.nEntries++;
          _this.adjustCursorsForInsert(index);
         // this.hook645();
         Label645:
          _this.setDirty(true);
          return (index | _this.INSERT_SUCCESS);
        }
   else {
          throw new InconsistentNodeException("Node " + _this.getNodeId() + " should have been split before calling insertEntry");
        }
      }
      protected IN _this;
      protected ChildReference entry;
      protected byte[] key;
      protected int index;
      protected int oldSize;
     // protected void hook645() throws DatabaseException {
     // }
      protected void hook646() throws DatabaseException {
      }
      protected void hook647() throws DatabaseException {
      }
    }
  @MethodObject static class IN_deleteEntry {
      IN_deleteEntry(    IN _this,    int index,    boolean maybeValidate){
        this._this=_this;
        this.index=index;
        this.maybeValidate=maybeValidate;
      }
      boolean execute() throws DatabaseException {
        if (_this.nEntries == 0) {
          return false;
        }
        assert maybeValidate ? _this.validateSubtreeBeforeDelete(index) : true;
        if (index < _this.nEntries) {
          //this.hook649();
          Label649:
          for (int i=index; i < _this.nEntries - 1; i++) {
            _this.setEntryInternal(i + 1,i);
          }
          _this.clearEntry(_this.nEntries - 1);
          //this.hook648();
          Label648:
          _this.nEntries--;
          _this.setDirty(true);
          _this.setProhibitNextDelta();
          this.hook616();
          return true;
        }
   else {
          return false;
        }
      }
      protected IN _this;
      protected int index;
      protected boolean maybeValidate;
      protected int oldLSNArraySize;
      protected void hook616() throws DatabaseException {
      }
      //protected void hook648() throws DatabaseException {
      //}
     // protected void hook649() throws DatabaseException {
      //}
    }
  @MethodObject static class IN_validateSubtreeBeforeDelete {
      IN_validateSubtreeBeforeDelete(    IN _this,    int index){
        this._this=_this;
        this.index=index;
      }
      boolean execute() throws DatabaseException {
        try {
          this.hook628();
          throw ReturnHack.returnBoolean;
        }
   catch (      ReturnBoolean r) {
          return r.value;
        }
      }
      protected IN _this;
      protected int index;
      protected boolean needToLatch;
      protected Node child;
      protected void hook628() throws DatabaseException {
        this.hook629();
        if (index >= _this.nEntries) {
          throw new ReturnBoolean(true);
        }
   else {
          child=_this.fetchTarget(index);
          throw new ReturnBoolean(child != null && child.isValidForDelete());
        }
      }
      protected void hook629() throws DatabaseException {
      }
    }
  @MethodObject static class IN_splitInternal {
      IN_splitInternal(    IN _this,    IN parent,    int childIndex,    int maxEntries,    int splitIndex){
        this._this=_this;
        this.parent=parent;
        this.childIndex=childIndex;
        this.maxEntries=maxEntries;
        this.splitIndex=splitIndex;
      }
      void execute() throws DatabaseException {
        if (_this.identifierKey == null) {
          throw new InconsistentNodeException("idkey is null");
        }
        idKeyIndex=_this.findEntry(_this.identifierKey,false,false);
        if (splitIndex < 0) {
          splitIndex=_this.nEntries / 2;
        }
  {
        }
        newSibling=null;
        if (idKeyIndex < splitIndex) {
          low=splitIndex;
          high=_this.nEntries;
        }
   else {
          low=0;
          high=splitIndex;
        }
        newIdKey=_this.entryKeyVals[low];
        parentLsn=DbLsn.NULL_LSN;
        newSibling=_this.createNewInstance(newIdKey,maxEntries,_this.level);
        this.hook631();
        oldMemorySize=_this.inMemorySize;
        //this.hook630();
        Label630:
        toIdx=0;
        deletedEntrySeen=false;
        binRef=null;
        for (int i=low; i < high; i++) {
          thisKey=_this.entryKeyVals[i];
          if (_this.isEntryPendingDeleted(i)) {
            if (!deletedEntrySeen) {
              deletedEntrySeen=true;
              binRef=new BINReference(newSibling.getNodeId(),_this.databaseImpl.getId(),newIdKey);
            }
            binRef.addDeletedKey(new Key(thisKey));
          }
          newSibling.setEntry(toIdx++,_this.entryTargets[i],thisKey,_this.getLsn(i),_this.entryStates[i]);
          _this.clearEntry(i);
        }
        Label636: //this.hook636();
        newSiblingNEntries=(high - low);
        if (low == 0) {
          _this.shiftEntriesLeft(newSiblingNEntries);
        }
        newSibling.nEntries=toIdx;
        _this.nEntries-=newSiblingNEntries;
        _this.setDirty(true);
        _this.adjustCursors(newSibling,low,high);
        env=_this.databaseImpl.getDbEnvironment();
        logManager=env.getLogManager();
        inMemoryINs=env.getInMemoryINs();
        newSiblingLsn=newSibling.logProvisional(logManager,parent);
        myNewLsn=_this.logProvisional(logManager,parent);
        if (low == 0) {
          if (childIndex == 0) {
            parent.updateEntryCompareKey(childIndex,newSibling,newSiblingLsn,newIdKey);
          }
   else {
            parent.updateEntry(childIndex,newSibling,newSiblingLsn);
          }
          insertOk1=parent.insertEntry(new ChildReference(_this,_this.entryKeyVals[0],myNewLsn));
          assert insertOk1;
        }
   else {
          if (childIndex == 0) {
            parent.updateEntryCompareKey(childIndex,_this,myNewLsn,_this.entryKeyVals[0]);
          }
   else {
            parent.updateEntry(childIndex,_this,myNewLsn);
          }
          insertOk2=parent.insertEntry(new ChildReference(newSibling,newIdKey,newSiblingLsn));
          assert insertOk2;
        }
        parentLsn=parent.log(logManager);
        if (parent.isRoot()) {
          parent.setDirty(true);
        }
        //this.hook650();
        Label650:
        inMemoryINs.add(newSibling);
        this.hook617();



      }
      protected IN _this;
      protected IN parent;
      protected int childIndex;
      protected int maxEntries;
      protected int splitIndex;
      protected int idKeyIndex;
      protected int low;
      protected int high;
      protected IN newSibling;
      protected byte[] newIdKey;
      protected long parentLsn;
      protected long oldMemorySize;
      protected int toIdx;
      protected boolean deletedEntrySeen;
      protected BINReference binRef;
      protected byte[] thisKey;
      protected int newSiblingNEntries;
      protected EnvironmentImpl env;
      protected LogManager logManager;
      protected INList inMemoryINs;
      protected long newSiblingLsn;
      protected long myNewLsn;
      protected boolean insertOk1;
      protected boolean insertOk2;
      protected long newSize;
      protected void hook617() throws DatabaseException {
      }
      protected void hook630() throws DatabaseException {
              }
      protected void hook631() throws DatabaseException {
      }
      protected void hook636() throws DatabaseException {
      }
     // protected void hook650() throws DatabaseException {
     // }
    }
  @MethodObject static class IN_verify {
      IN_verify(    IN _this,    byte[] maxKey){
        this._this=_this;
        this.maxKey=maxKey;
      }
      void execute() throws DatabaseException {
        try {
          this.hook632();
          userCompareToFcn=(_this.databaseImpl == null ? null : _this.getKeyComparator());
          key1=null;
          for (int i=1; i < _this.nEntries; i++) {
            key1=_this.entryKeyVals[i];
            key2=_this.entryKeyVals[i - 1];
            s=Key.compareKeys(key1,key2,userCompareToFcn);
            if (s <= 0) {
              throw new InconsistentNodeException("IN " + _this.getNodeId() + " key "+ (i - 1)+ " ("+ Key.dumpString(key2,0)+ ") and "+ i+ " ("+ Key.dumpString(key1,0)+ ") are out of order");
            }
          }
          inconsistent=false;
          if (maxKey != null && key1 != null) {
            if (Key.compareKeys(key1,maxKey,userCompareToFcn) >= 0) {
              inconsistent=true;
            }
          }
          if (inconsistent) {
            throw new InconsistentNodeException("IN " + _this.getNodeId() + " has entry larger than next entry in parent.");
          }
        }
   catch (      DatabaseException DE) {
          DE.printStackTrace(System.out);
        }
   finally {
          this.hook633();
        }
      }
      protected IN _this;
      protected byte[] maxKey;
      protected boolean unlatchThis;
      protected Comparator userCompareToFcn;
      protected byte[] key1;
      protected byte[] key2;
      protected int s;
      protected boolean inconsistent;
      protected void hook632() throws DatabaseException {
      }
      protected void hook633() throws DatabaseException {
      }
    }
  @MethodObject static class IN_isValidForDelete {
      IN_isValidForDelete(    IN _this){
        this._this=_this;
      }
      boolean execute() throws DatabaseException {
        try {
          this.hook634();
          throw ReturnHack.returnBoolean;
        }
   catch (      ReturnBoolean r) {
          return r.value;
        }
      }
      protected IN _this;
      protected boolean needToLatch;
      protected Node child;
      protected void hook634() throws DatabaseException {
        this.hook635();
        if (_this.nEntries > 1) {
          throw new ReturnBoolean(false);
        }
   else       if (_this.nEntries == 1) {
          child=_this.fetchTarget(0);
          throw new ReturnBoolean(child != null && child.isValidForDelete());
        }
   else {
          throw new ReturnBoolean(true);
        }
      }
      protected void hook635() throws DatabaseException {
      }
    }
  @MethodObject static class IN_trackProvisionalObsolete {
      IN_trackProvisionalObsolete(    IN _this,    IN child,    long obsoleteLsn1,    long obsoleteLsn2){
        this._this=_this;
        this.child=child;
        this.obsoleteLsn1=obsoleteLsn1;
        this.obsoleteLsn2=obsoleteLsn2;
      }
      void execute(){
        memDelta=0;
        if (child.provisionalObsolete != null) {
          //this.hook652();
          Label652:
          if (_this.provisionalObsolete != null) {
            _this.provisionalObsolete.addAll(child.provisionalObsolete);
          }
   else {
            _this.provisionalObsolete=child.provisionalObsolete;
          }
          child.provisionalObsolete=null;
          //this.hook651();
          Label651:
        }
        if (obsoleteLsn1 != DbLsn.NULL_LSN || obsoleteLsn2 != DbLsn.NULL_LSN) {
          if (_this.provisionalObsolete == null) {
            _this.provisionalObsolete=new ArrayList();
          }
          if (obsoleteLsn1 != DbLsn.NULL_LSN) {
            _this.provisionalObsolete.add(new Long(obsoleteLsn1));
            //this.hook653();
            Label653:
          }
          if (obsoleteLsn2 != DbLsn.NULL_LSN) {
            _this.provisionalObsolete.add(new Long(obsoleteLsn2));
            //this.hook654();
            Label654:
          }
        }
      }
      protected IN _this;
      protected IN child;
      protected long obsoleteLsn1;
      protected long obsoleteLsn2;
      protected int memDelta;
      protected int childMemDelta;
      protected void hook651(){
      }
      //protected void hook652(){
      //}
      protected void hook653(){
      }
     // protected void hook654(){
     // }
    }
  @MethodObject static class IN_flushProvisionalObsolete {
      IN_flushProvisionalObsolete(    IN _this,    LogManager logManager){
        this._this=_this;
        this.logManager=logManager;
      }
      void execute() throws DatabaseException {
        if (_this.provisionalObsolete != null) {
          //this.hook656();
          Label656:
          logManager.countObsoleteINs(_this.provisionalObsolete);
          _this.provisionalObsolete=null;
          //this.hook655();
          Label655:
        }
      }
      protected IN _this;
      protected LogManager logManager;
      protected int memDelta;
      protected void hook655() throws DatabaseException {
      }
      protected void hook656() throws DatabaseException {
      }
    }
}
