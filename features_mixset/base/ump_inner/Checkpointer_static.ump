
namespace com.sleepycat.je.recovery;
class Checkpointer {
 static class CheckpointReference {
  DatabaseImpl db;
  long nodeId;
  boolean containsDuplicates;
  boolean isDbRoot;
  protected byte[] mainTreeKey;
  protected byte[] dupTreeKey;
  public CheckpointReference(DatabaseImpl db, long nodeId, boolean containsDuplicates, boolean isDbRoot, byte[] mainTreeKey, byte[] dupTreeKey) {
   this.db = db;
   this.nodeId = nodeId;
   this.containsDuplicates = containsDuplicates;
   this.isDbRoot = isDbRoot;
   this.mainTreeKey = mainTreeKey;
   this.dupTreeKey = dupTreeKey;
  }
  public boolean equals(Object o) {
   if (!(o instanceof CheckpointReference)) {
    return false;
   }
   CheckpointReference other = (CheckpointReference) o;
   return nodeId == other.nodeId;
  }
  public int hashCode() {
   return (int) nodeId;
  }
 }
 static class Checkpointer_getWakeupPeriod {
  Checkpointer_getWakeupPeriod(DbConfigManager configManager) {
   this.configManager = configManager;
  }
  long execute() throws IllegalArgumentException, DatabaseException {
    Label541:   ; //this.hook541();
    Label519:   ; //this.hook519();
    result = 0;
    Label540:   ; //this.hook540();
    return result;
  }
  protected DbConfigManager configManager;
  protected long wakeupPeriod;
  protected long bytePeriod;
  protected int result;
  protected void hook519() throws IllegalArgumentException, DatabaseException {}
  //   protected void hook540() throws IllegalArgumentException, DatabaseException {
  //  }
  protected void hook541() throws IllegalArgumentException, DatabaseException {}
 }
 static class Checkpointer_isRunnable {
  Checkpointer_isRunnable(Checkpointer _this, CheckpointConfig config) {
   this._this = _this;
   this.config = config;
  }
  boolean execute() throws DatabaseException {

   useBytesInterval = 0;
   useTimeInterval = 0;
   nextLsn = DbLsn.NULL_LSN;
   try {
    if (config.getForce()) {
     return true;
    } else {
     Label543:   ; //this.hook543();
     Label544:   ; //added from this.hook543();
    }
    Label542:   ; //this.hook542();
    return false;
   } 
   finally {
    Label521:   ; //this.hook521();
   }
   //throw ReturnHack.returnBoolean;

   //catch (ReturnBoolean r) {    return r.value;}
  }
  protected Checkpointer _this;
  protected CheckpointConfig config;
  protected long useBytesInterval;
  protected long useTimeInterval;
  protected long nextLsn;
  protected long lastUsedLsn;
  protected StringBuffer sb;
  //      protected void hook521() throws DatabaseException {  }
  // protected void hook542() throws DatabaseException {
  //  throw new ReturnBoolean(false);
  // }
  //    protected void hook543() throws DatabaseException {
  //     this.hook544();
  //  }
  //  protected void hook544() throws DatabaseException {
  // }
 }
 
  static class Checkpointer_selectDirtyINs {
  Checkpointer_selectDirtyINs(Checkpointer _this, boolean flushAll, boolean flushExtraLevel) {
   this._this = _this;
   this.flushAll = flushAll;
   this.flushExtraLevel = flushExtraLevel;
  }
  SortedMap execute() throws DatabaseException {
   newDirtyMap = new TreeMap();
   inMemINs = _this.envImpl.getInMemoryINs();
   Label529:   ; //this.hook529();
    //this.hook553();
    Label553:   ;
    //this.hook528();
    Label528:   ;
    try {
     iter = inMemINs.iterator();
     while (iter.hasNext()) {
      in = (IN) iter.next(); in .latch(false);
      //this.hook530();
      Label530:   ;
       if ( in .getDirty()) {
        level = new Integer( in .getLevel());
        if (newDirtyMap.containsKey(level)) {
         dirtySet = (Set) newDirtyMap.get(level);
        } else {
         dirtySet = new HashSet();
         newDirtyMap.put(level, dirtySet);
        }
        dirtySet.add(new CheckpointReference( in .getDatabase(), in .getNodeId(), in .containsDuplicates(), in .isDbRoot(), in .getMainTreeKey(), in .getDupTreeKey()));
       }
     }
     Label530_1:   ;
      //this.hook554(); //excute()
      Label554:   ;
      if (newDirtyMap.size() > 0) {
       if (flushAll) {
        _this.highestFlushLevel = _this.envImpl.getDbMapTree().getHighestLevel();
       } else {
        _this.highestFlushLevel = ((Integer) newDirtyMap.lastKey()).intValue();
        if (flushExtraLevel) {
         _this.highestFlushLevel += 1;
        }
       }
      }
     else {
      _this.highestFlushLevel = IN.MAX_LEVEL;
     }
    }
   finally {
    Label528_1:   ; //;

   }
   //end hook528
   return newDirtyMap;
  }
  protected Checkpointer _this;
  protected boolean flushAll;
  protected boolean flushExtraLevel;
  protected SortedMap newDirtyMap;
  protected INList inMemINs;
  protected long totalSize;
  protected MemoryBudget mb;
  protected Iterator iter;
  protected IN in ;
  protected Integer level;
  protected Set dirtySet;



 }
}
