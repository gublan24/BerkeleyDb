/* Generated By:JavaCC: Do not edit this line. PythonParser.java */
package tmp.generated_python;
import java.io.*;
import java.util.*;
import cide.gast.*;
import cide.gparser.*;

public class PythonParser implements PythonParserConstants {

  final public file_input file_input() throws ParseException {
        newlineOrStmt newlineOrStmt;
        ArrayList<newlineOrStmt> newlineOrStmtList = new ArrayList<newlineOrStmt>();
        Token t;
        ASTStringNode eof;
        Token firstToken=token;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEWLINE:
      case LPAREN:
      case LBRACE:
      case LBRACKET:
      case PLUS:
      case MINUS:
      case NOT:
      case NOT_BOOL:
      case LAMBDA:
      case IF:
      case WHILE:
      case FOR:
      case TRY:
      case DEF:
      case CLASS:
      case PRINT:
      case PASS:
      case BREAK:
      case CONTINUE:
      case RETURN:
      case YIELD:
      case IMPORT:
      case FROM:
      case DEL:
      case RAISE:
      case GLOBAL:
      case EXEC:
      case ASSERT:
      case AS:
      case NAME:
      case DECNUMBER:
      case HEXNUMBER:
      case OCTNUMBER:
      case FLOAT:
      case COMPLEX:
      case SINGLE_STRING:
      case SINGLE_STRING2:
      case TRIPLE_STRING:
      case TRIPLE_STRING2:
      case SINGLE_USTRING:
      case SINGLE_USTRING2:
      case TRIPLE_USTRING:
      case TRIPLE_USTRING2:
      case 135:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      newlineOrStmt = newlineOrStmt();
                                       newlineOrStmtList.add(newlineOrStmt);
    }
    t = jj_consume_token(0);
                                                                                        eof=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new file_input(newlineOrStmtList, eof, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public newlineOrStmt newlineOrStmt() throws ParseException {
        Token t;
        ASTStringNode newline;
        stmt stmt;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEWLINE:
      t = jj_consume_token(NEWLINE);
                    newline=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new newlineOrStmt1(newline, firstToken.next,token);}
      break;
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case IF:
    case WHILE:
    case FOR:
    case TRY:
    case DEF:
    case CLASS:
    case PRINT:
    case PASS:
    case BREAK:
    case CONTINUE:
    case RETURN:
    case YIELD:
    case IMPORT:
    case FROM:
    case DEL:
    case RAISE:
    case GLOBAL:
    case EXEC:
    case ASSERT:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      stmt = stmt();
         {if (true) return new newlineOrStmt2(stmt, firstToken.next,token);}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public funcdef funcdef() throws ParseException {
        AnyName anyName;
        parameters parameters;
        suite suite;
        Token firstToken=token;
    jj_consume_token(DEF);
    anyName = AnyName();
    parameters = parameters();
    jj_consume_token(COLON);
    suite = suite();
         {if (true) return new funcdef(anyName, parameters, suite, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public parameters parameters() throws ParseException {
        varargslist varargslist = null;
        Token firstToken=token;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case MULTIPLY:
    case POWER:
    case AS:
    case NAME:
      varargslist = varargslist();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
         {if (true) return new parameters(varargslist, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public varargslist varargslist() throws ParseException {
        defaultarg defaultarg;
        defaultarg defaultarg1;
        ArrayList<defaultarg> defaultarg1List = new ArrayList<defaultarg>();
        ExtraArgList extraArgList = null;
        ExtraKeywordList extraKeywordList = null;
        ASTTextNode text578 = null;
        ExtraArgList extraArgList1;
        ExtraKeywordList extraKeywordList1 = null;
        ExtraKeywordList extraKeywordList2;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case AS:
    case NAME:
      defaultarg = defaultarg();
      label_2:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_2;
        }
        jj_consume_token(COMMA);
        defaultarg1 = defaultarg();
                                                                           defaultarg1List.add(defaultarg1);
      }
      if (jj_2_2(3)) {
        jj_consume_token(COMMA);
        extraArgList = ExtraArgList();
      } else {
        ;
      }
      if (jj_2_3(2)) {
        jj_consume_token(COMMA);
        extraKeywordList = ExtraKeywordList();
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
                                                                                                                                                                                                                            text578=new ASTTextNode(",",new WToken(token));
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
         {if (true) return new varargslist1(defaultarg, defaultarg1List, extraArgList, extraKeywordList, text578, firstToken.next,token);}
      break;
    default:
      jj_la1[5] = jj_gen;
      if (jj_2_4(2)) {
        extraArgList1 = ExtraArgList();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          extraKeywordList1 = ExtraKeywordList();
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
         {if (true) return new varargslist2(extraArgList1, extraKeywordList1, firstToken.next,token);}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
        case POWER:
          extraKeywordList2 = ExtraKeywordList();
         {if (true) return new varargslist3(extraKeywordList2, firstToken.next,token);}
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExtraArgList ExtraArgList() throws ParseException {
        Name name;
        Token firstToken=token;
    jj_consume_token(MULTIPLY);
    name = Name();
         {if (true) return new ExtraArgList(name, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public ExtraKeywordList ExtraKeywordList() throws ParseException {
        power power;
        Name name;
        Token firstToken=token;
    power = power();
    name = Name();
         {if (true) return new ExtraKeywordList(power, name, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public defaultarg defaultarg() throws ParseException {
        fpdef fpdef;
        test test = null;
        Token firstToken=token;
    fpdef = fpdef();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      test = test();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
         {if (true) return new defaultarg(fpdef, test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public fpdef fpdef() throws ParseException {
        Name name;
        fplist fplist;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case NAME:
      name = Name();
         {if (true) return new fpdef1(name, firstToken.next,token);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      fplist = fplist();
      jj_consume_token(RPAREN);
         {if (true) return new fpdef2(fplist, firstToken.next,token);}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public fplist fplist() throws ParseException {
        fpdef fpdef;
        fpdef fpdef1;
        ArrayList<fpdef> fpdef1List = new ArrayList<fpdef>();
        ASTTextNode text579 = null;
        Token firstToken=token;
    fpdef = fpdef();
    label_3:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_3;
      }
      jj_consume_token(COMMA);
      fpdef1 = fpdef();
                                                       fpdef1List.add(fpdef1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                        text579=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
         {if (true) return new fplist(fpdef, fpdef1List, text579, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public stmt stmt() throws ParseException {
        simple_stmt simple_stmt;
        compound_stmt compound_stmt;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case PRINT:
    case PASS:
    case BREAK:
    case CONTINUE:
    case RETURN:
    case YIELD:
    case IMPORT:
    case FROM:
    case DEL:
    case RAISE:
    case GLOBAL:
    case EXEC:
    case ASSERT:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      simple_stmt = simple_stmt();
         {if (true) return new stmt1(simple_stmt, firstToken.next,token);}
      break;
    case IF:
    case WHILE:
    case FOR:
    case TRY:
    case DEF:
    case CLASS:
      compound_stmt = compound_stmt();
         {if (true) return new stmt2(compound_stmt, firstToken.next,token);}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public simple_stmt simple_stmt() throws ParseException {
        small_stmt small_stmt;
        small_stmt small_stmt1;
        ArrayList<small_stmt> small_stmt1List = new ArrayList<small_stmt>();
        ASTTextNode text580 = null;
        Token t;
        ASTStringNode newline;
        Token firstToken=token;
    small_stmt = small_stmt();
    label_4:
    while (true) {
      if (jj_2_6(2)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(SEMICOLON);
      small_stmt1 = small_stmt();
                                                                           small_stmt1List.add(small_stmt1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
                                                                                                                      text580=new ASTTextNode(";",new WToken(token));
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    t = jj_consume_token(NEWLINE);
                                                                                                                                                                                    newline=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new simple_stmt(small_stmt, small_stmt1List, text580, newline, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public small_stmt small_stmt() throws ParseException {
        expr_stmt expr_stmt;
        print_stmt print_stmt;
        del_stmt del_stmt;
        pass_stmt pass_stmt;
        flow_stmt flow_stmt;
        import_stmt import_stmt;
        global_stmt global_stmt;
        exec_stmt exec_stmt;
        assert_stmt assert_stmt;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      expr_stmt = expr_stmt();
         {if (true) return new small_stmt1(expr_stmt, firstToken.next,token);}
      break;
    case PRINT:
      print_stmt = print_stmt();
         {if (true) return new small_stmt2(print_stmt, firstToken.next,token);}
      break;
    case DEL:
      del_stmt = del_stmt();
         {if (true) return new small_stmt3(del_stmt, firstToken.next,token);}
      break;
    case PASS:
      pass_stmt = pass_stmt();
         {if (true) return new small_stmt4(pass_stmt, firstToken.next,token);}
      break;
    case BREAK:
    case CONTINUE:
    case RETURN:
    case YIELD:
    case RAISE:
      flow_stmt = flow_stmt();
         {if (true) return new small_stmt5(flow_stmt, firstToken.next,token);}
      break;
    case IMPORT:
    case FROM:
      import_stmt = import_stmt();
         {if (true) return new small_stmt6(import_stmt, firstToken.next,token);}
      break;
    case GLOBAL:
      global_stmt = global_stmt();
         {if (true) return new small_stmt7(global_stmt, firstToken.next,token);}
      break;
    case EXEC:
      exec_stmt = exec_stmt();
         {if (true) return new small_stmt8(exec_stmt, firstToken.next,token);}
      break;
    case ASSERT:
      assert_stmt = assert_stmt();
         {if (true) return new small_stmt9(assert_stmt, firstToken.next,token);}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public expr_stmt expr_stmt() throws ParseException {
        SmartTestList smartTestList;
        expr_stmtEnd expr_stmtEnd;
        Token firstToken=token;
    smartTestList = SmartTestList();
    expr_stmtEnd = expr_stmtEnd();
         {if (true) return new expr_stmt(smartTestList, expr_stmtEnd, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public expr_stmtEnd expr_stmtEnd() throws ParseException {
        Token t;
        ASTStringNode pluseq;
        SmartTestList smartTestList;
        ASTStringNode minuseq;
        SmartTestList smartTestList1;
        ASTStringNode multiplyeq;
        SmartTestList smartTestList2;
        ASTStringNode divideeq;
        SmartTestList smartTestList3;
        ASTStringNode floordivideeq;
        SmartTestList smartTestList4;
        ASTStringNode moduloeq;
        SmartTestList smartTestList5;
        ASTStringNode andeq;
        SmartTestList smartTestList6;
        ASTStringNode oreq;
        SmartTestList smartTestList7;
        ASTStringNode xoreq;
        SmartTestList smartTestList8;
        ASTStringNode lshifteq;
        SmartTestList smartTestList9;
        ASTStringNode rshifteq;
        SmartTestList smartTestList10;
        ASTStringNode powereq;
        SmartTestList smartTestList11;
        SmartTestList smartTestList12;
        ArrayList<SmartTestList> smartTestList12List = new ArrayList<SmartTestList>();
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUSEQ:
      t = jj_consume_token(PLUSEQ);
                   pluseq=new ASTStringNode(t.image,new WToken(t));
      smartTestList = SmartTestList();
         {if (true) return new expr_stmtEnd1(pluseq, smartTestList, firstToken.next,token);}
      break;
    case MINUSEQ:
      t = jj_consume_token(MINUSEQ);
                    minuseq=new ASTStringNode(t.image,new WToken(t));
      smartTestList1 = SmartTestList();
         {if (true) return new expr_stmtEnd2(minuseq, smartTestList1, firstToken.next,token);}
      break;
    case MULTIPLYEQ:
      t = jj_consume_token(MULTIPLYEQ);
                       multiplyeq=new ASTStringNode(t.image,new WToken(t));
      smartTestList2 = SmartTestList();
         {if (true) return new expr_stmtEnd3(multiplyeq, smartTestList2, firstToken.next,token);}
      break;
    case DIVIDEEQ:
      t = jj_consume_token(DIVIDEEQ);
                     divideeq=new ASTStringNode(t.image,new WToken(t));
      smartTestList3 = SmartTestList();
         {if (true) return new expr_stmtEnd4(divideeq, smartTestList3, firstToken.next,token);}
      break;
    case FLOORDIVIDEEQ:
      t = jj_consume_token(FLOORDIVIDEEQ);
                          floordivideeq=new ASTStringNode(t.image,new WToken(t));
      smartTestList4 = SmartTestList();
         {if (true) return new expr_stmtEnd5(floordivideeq, smartTestList4, firstToken.next,token);}
      break;
    case MODULOEQ:
      t = jj_consume_token(MODULOEQ);
                     moduloeq=new ASTStringNode(t.image,new WToken(t));
      smartTestList5 = SmartTestList();
         {if (true) return new expr_stmtEnd6(moduloeq, smartTestList5, firstToken.next,token);}
      break;
    case ANDEQ:
      t = jj_consume_token(ANDEQ);
                  andeq=new ASTStringNode(t.image,new WToken(t));
      smartTestList6 = SmartTestList();
         {if (true) return new expr_stmtEnd7(andeq, smartTestList6, firstToken.next,token);}
      break;
    case OREQ:
      t = jj_consume_token(OREQ);
                 oreq=new ASTStringNode(t.image,new WToken(t));
      smartTestList7 = SmartTestList();
         {if (true) return new expr_stmtEnd8(oreq, smartTestList7, firstToken.next,token);}
      break;
    case XOREQ:
      t = jj_consume_token(XOREQ);
                  xoreq=new ASTStringNode(t.image,new WToken(t));
      smartTestList8 = SmartTestList();
         {if (true) return new expr_stmtEnd9(xoreq, smartTestList8, firstToken.next,token);}
      break;
    case LSHIFTEQ:
      t = jj_consume_token(LSHIFTEQ);
                     lshifteq=new ASTStringNode(t.image,new WToken(t));
      smartTestList9 = SmartTestList();
         {if (true) return new expr_stmtEnd10(lshifteq, smartTestList9, firstToken.next,token);}
      break;
    case RSHIFTEQ:
      t = jj_consume_token(RSHIFTEQ);
                     rshifteq=new ASTStringNode(t.image,new WToken(t));
      smartTestList10 = SmartTestList();
         {if (true) return new expr_stmtEnd11(rshifteq, smartTestList10, firstToken.next,token);}
      break;
    case POWEREQ:
      t = jj_consume_token(POWEREQ);
                    powereq=new ASTStringNode(t.image,new WToken(t));
      smartTestList11 = SmartTestList();
         {if (true) return new expr_stmtEnd12(powereq, smartTestList11, firstToken.next,token);}
      break;
    default:
      jj_la1[14] = jj_gen;
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQUAL:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_5;
        }
        jj_consume_token(EQUAL);
        smartTestList12 = SmartTestList();
                                             smartTestList12List.add(smartTestList12);
      }
         {if (true) return new expr_stmtEnd13(smartTestList12List, firstToken.next,token);}
    }
    throw new Error("Missing return statement in function");
  }

  final public print_stmt print_stmt() throws ParseException {
        Token t;
        ASTStringNode print;
        ASTStringNode rshift;
        test test;
        print_stmtEndP print_stmtEndP = null;
        ASTStringNode print1;
        print_stmtEndA print_stmtEndA;
        ASTStringNode print2;
        Token firstToken=token;
    if (jj_2_7(2)) {
      t = jj_consume_token(PRINT);
                               print=new ASTStringNode(t.image,new WToken(t));
      t = jj_consume_token(RSHIFT);
                                                                                           rshift=new ASTStringNode(t.image,new WToken(t));
      test = test();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        print_stmtEndP = print_stmtEndP();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
         {if (true) return new print_stmt1(print, rshift, test, print_stmtEndP, firstToken.next,token);}
    } else if (jj_2_8(2)) {
      t = jj_consume_token(PRINT);
                               print1=new ASTStringNode(t.image,new WToken(t));
      print_stmtEndA = print_stmtEndA();
         {if (true) return new print_stmt2(print1, print_stmtEndA, firstToken.next,token);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRINT:
        t = jj_consume_token(PRINT);
                  print2=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new print_stmt3(print2, firstToken.next,token);}
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public print_stmtEndP print_stmtEndP() throws ParseException {
        test test;
        ArrayList<test> testList = new ArrayList<test>();
        ASTTextNode text581 = null;
        Token firstToken=token;
    label_6:
    while (true) {
      jj_consume_token(COMMA);
      test = test();
                                      testList.add(test);
      if (jj_2_9(2)) {
        ;
      } else {
        break label_6;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                   text581=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
         {if (true) return new print_stmtEndP(testList, text581, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public print_stmtEndA print_stmtEndA() throws ParseException {
        test test;
        test test1;
        ArrayList<test> test1List = new ArrayList<test>();
        ASTTextNode text582 = null;
        Token firstToken=token;
    test = test();
    label_7:
    while (true) {
      if (jj_2_10(2)) {
        ;
      } else {
        break label_7;
      }
      jj_consume_token(COMMA);
      test1 = test();
                                                   test1List.add(test1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                  text582=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
         {if (true) return new print_stmtEndA(test, test1List, text582, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public del_stmt del_stmt() throws ParseException {
        Token t;
        ASTStringNode del;
        exprlist exprlist;
        Token firstToken=token;
    t = jj_consume_token(DEL);
                del=new ASTStringNode(t.image,new WToken(t));
    exprlist = exprlist();
         {if (true) return new del_stmt(del, exprlist, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public pass_stmt pass_stmt() throws ParseException {
        Token t;
        ASTStringNode pass;
        Token firstToken=token;
    t = jj_consume_token(PASS);
                 pass=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new pass_stmt(pass, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public flow_stmt flow_stmt() throws ParseException {
        Token t;
        ASTStringNode break_kw;
        ASTStringNode continue_kw;
        return_stmt return_stmt;
        yield_stmt yield_stmt;
        raise_stmt raise_stmt;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
      t = jj_consume_token(BREAK);
                  break_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new flow_stmt1(break_kw, firstToken.next,token);}
      break;
    case CONTINUE:
      t = jj_consume_token(CONTINUE);
                     continue_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new flow_stmt2(continue_kw, firstToken.next,token);}
      break;
    case RETURN:
      return_stmt = return_stmt();
         {if (true) return new flow_stmt3(return_stmt, firstToken.next,token);}
      break;
    case YIELD:
      yield_stmt = yield_stmt();
         {if (true) return new flow_stmt4(yield_stmt, firstToken.next,token);}
      break;
    case RAISE:
      raise_stmt = raise_stmt();
         {if (true) return new flow_stmt5(raise_stmt, firstToken.next,token);}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public return_stmt return_stmt() throws ParseException {
        Token t;
        ASTStringNode return_kw;
        SmartTestList smartTestList = null;
        Token firstToken=token;
    t = jj_consume_token(RETURN);
                   return_kw=new ASTStringNode(t.image,new WToken(t));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      smartTestList = SmartTestList();
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
         {if (true) return new return_stmt(return_kw, smartTestList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public yield_stmt yield_stmt() throws ParseException {
        Token t;
        ASTStringNode yield;
        SmartTestList smartTestList;
        Token firstToken=token;
    t = jj_consume_token(YIELD);
                  yield=new ASTStringNode(t.image,new WToken(t));
    smartTestList = SmartTestList();
         {if (true) return new yield_stmt(yield, smartTestList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public raise_stmt raise_stmt() throws ParseException {
        Token t;
        ASTStringNode raise;
        raise_stmt_end raise_stmt_end = null;
        Token firstToken=token;
    t = jj_consume_token(RAISE);
                  raise=new ASTStringNode(t.image,new WToken(t));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      raise_stmt_end = raise_stmt_end();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
         {if (true) return new raise_stmt(raise, raise_stmt_end, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public raise_stmt_end raise_stmt_end() throws ParseException {
        test test;
        testcommatest testcommatest = null;
        Token firstToken=token;
    test = test();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      testcommatest = testcommatest();
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
         {if (true) return new raise_stmt_end(test, testcommatest, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public testcommatest testcommatest() throws ParseException {
        test test;
        test test1 = null;
        Token firstToken=token;
    test = test();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      test1 = test();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
         {if (true) return new testcommatest(test, test1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public import_stmt import_stmt() throws ParseException {
        Token t;
        ASTStringNode import_kw;
        Import import_KW;
        ASTStringNode from;
        ImportFrom importFrom;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPORT:
      t = jj_consume_token(IMPORT);
                   import_kw=new ASTStringNode(t.image,new WToken(t));
      import_KW = Import();
         {if (true) return new import_stmt1(import_kw, import_KW, firstToken.next,token);}
      break;
    case FROM:
      t = jj_consume_token(FROM);
                 from=new ASTStringNode(t.image,new WToken(t));
      importFrom = ImportFrom();
         {if (true) return new import_stmt2(from, importFrom, firstToken.next,token);}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Import Import() throws ParseException {
        dotted_as_name dotted_as_name;
        dotted_as_name dotted_as_name1;
        ArrayList<dotted_as_name> dotted_as_name1List = new ArrayList<dotted_as_name>();
        Token firstToken=token;
    dotted_as_name = dotted_as_name();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      dotted_as_name1 = dotted_as_name();
                                                                              dotted_as_name1List.add(dotted_as_name1);
    }
         {if (true) return new Import(dotted_as_name, dotted_as_name1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public ImportFrom ImportFrom() throws ParseException {
        dotted_name dotted_name;
        Token t;
        ASTStringNode import_kw;
        ImportFromEnd importFromEnd;
        Token firstToken=token;
    dotted_name = dotted_name();
    t = jj_consume_token(IMPORT);
                                             import_kw=new ASTStringNode(t.image,new WToken(t));
    importFromEnd = ImportFromEnd();
         {if (true) return new ImportFrom(dotted_name, import_kw, importFromEnd, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public ImportFromEnd ImportFromEnd() throws ParseException {
        import_as_name import_as_name;
        import_as_name import_as_name1;
        ArrayList<import_as_name> import_as_name1List = new ArrayList<import_as_name>();
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
      jj_consume_token(MULTIPLY);
         {if (true) return new ImportFromEnd1(firstToken.next,token);}
      break;
    case OR_BOOL:
    case AND_BOOL:
    case NOT_BOOL:
    case IS:
    case IN:
    case LAMBDA:
    case IF:
    case ELSE:
    case ELIF:
    case WHILE:
    case FOR:
    case TRY:
    case EXCEPT:
    case DEF:
    case CLASS:
    case FINALLY:
    case PRINT:
    case PASS:
    case BREAK:
    case CONTINUE:
    case RETURN:
    case YIELD:
    case IMPORT:
    case FROM:
    case DEL:
    case RAISE:
    case GLOBAL:
    case EXEC:
    case ASSERT:
    case AS:
    case NAME:
      import_as_name = import_as_name();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        import_as_name1 = import_as_name();
                                                                              import_as_name1List.add(import_as_name1);
      }
         {if (true) return new ImportFromEnd2(import_as_name, import_as_name1List, firstToken.next,token);}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public dotted_as_name dotted_as_name() throws ParseException {
        dotted_name dotted_name;
        Name name = null;
        Token firstToken=token;
    dotted_name = dotted_name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      name = Name();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
         {if (true) return new dotted_as_name(dotted_name, name, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public dotted_name dotted_name() throws ParseException {
        AnyName anyName;
        AnyName anyName1;
        ArrayList<AnyName> anyName1List = new ArrayList<AnyName>();
        Token firstToken=token;
    anyName = AnyName();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_10;
      }
      jj_consume_token(DOT);
      anyName1 = AnyName();
                                                  anyName1List.add(anyName1);
    }
         {if (true) return new dotted_name(anyName, anyName1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public import_as_name import_as_name() throws ParseException {
        AnyName anyName;
        Name name = null;
        Token firstToken=token;
    anyName = AnyName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      name = Name();
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
         {if (true) return new import_as_name(anyName, name, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public global_stmt global_stmt() throws ParseException {
        Token t;
        ASTStringNode global;
        Name name;
        Name name1;
        ArrayList<Name> name1List = new ArrayList<Name>();
        Token firstToken=token;
    t = jj_consume_token(GLOBAL);
                   global=new ASTStringNode(t.image,new WToken(t));
    name = Name();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_11;
      }
      jj_consume_token(COMMA);
      name1 = Name();
                                                                                                   name1List.add(name1);
    }
         {if (true) return new global_stmt(global, name, name1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public exec_stmt exec_stmt() throws ParseException {
        expr expr;
        exec_stmt_end exec_stmt_end = null;
        Token firstToken=token;
    jj_consume_token(EXEC);
    expr = expr();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      exec_stmt_end = exec_stmt_end();
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
         {if (true) return new exec_stmt(expr, exec_stmt_end, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public exec_stmt_end exec_stmt_end() throws ParseException {
        test test;
        test test1 = null;
        Token firstToken=token;
    test = test();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      test1 = test();
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
         {if (true) return new exec_stmt_end(test, test1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public assert_stmt assert_stmt() throws ParseException {
        test test;
        test test1 = null;
        Token firstToken=token;
    jj_consume_token(ASSERT);
    test = test();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      test1 = test();
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
         {if (true) return new assert_stmt(test, test1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public compound_stmt compound_stmt() throws ParseException {
        if_stmt if_stmt;
        while_stmt while_stmt;
        for_stmt for_stmt;
        try_stmt try_stmt;
        funcdef funcdef;
        classdef classdef;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      if_stmt = if_stmt();
         {if (true) return new compound_stmt1(if_stmt, firstToken.next,token);}
      break;
    case WHILE:
      while_stmt = while_stmt();
         {if (true) return new compound_stmt2(while_stmt, firstToken.next,token);}
      break;
    case FOR:
      for_stmt = for_stmt();
         {if (true) return new compound_stmt3(for_stmt, firstToken.next,token);}
      break;
    case TRY:
      try_stmt = try_stmt();
         {if (true) return new compound_stmt4(try_stmt, firstToken.next,token);}
      break;
    case DEF:
      funcdef = funcdef();
         {if (true) return new compound_stmt5(funcdef, firstToken.next,token);}
      break;
    case CLASS:
      classdef = classdef();
         {if (true) return new compound_stmt6(classdef, firstToken.next,token);}
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public if_stmt if_stmt() throws ParseException {
        test test;
        suite suite;
        elif_stmt elif_stmt;
        ArrayList<elif_stmt> elif_stmtList = new ArrayList<elif_stmt>();
        suite suite1 = null;
        Token firstToken=token;
    jj_consume_token(IF);
    test = test();
    jj_consume_token(COLON);
    suite = suite();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELIF:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_12;
      }
      elif_stmt = elif_stmt();
                                                                  elif_stmtList.add(elif_stmt);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      jj_consume_token(COLON);
      suite1 = suite();
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
         {if (true) return new if_stmt(test, suite, elif_stmtList, suite1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public elif_stmt elif_stmt() throws ParseException {
        test test;
        suite suite;
        Token firstToken=token;
    jj_consume_token(ELIF);
    test = test();
    jj_consume_token(COLON);
    suite = suite();
         {if (true) return new elif_stmt(test, suite, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public while_stmt while_stmt() throws ParseException {
        test test;
        suite suite;
        suite suite1 = null;
        Token firstToken=token;
    jj_consume_token(WHILE);
    test = test();
    jj_consume_token(COLON);
    suite = suite();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      jj_consume_token(COLON);
      suite1 = suite();
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
         {if (true) return new while_stmt(test, suite, suite1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public for_stmt for_stmt() throws ParseException {
        exprlist exprlist;
        SmartTestList smartTestList;
        suite suite;
        suite suite1 = null;
        Token firstToken=token;
    jj_consume_token(FOR);
    exprlist = exprlist();
    jj_consume_token(IN);
    smartTestList = SmartTestList();
    jj_consume_token(COLON);
    suite = suite();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      jj_consume_token(COLON);
      suite1 = suite();
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
         {if (true) return new for_stmt(exprlist, smartTestList, suite, suite1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public try_stmt try_stmt() throws ParseException {
        suite suite;
        tryEnd tryEnd;
        Token firstToken=token;
    jj_consume_token(TRY);
    jj_consume_token(COLON);
    suite = suite();
    tryEnd = tryEnd();
         {if (true) return new try_stmt(suite, tryEnd, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public tryEnd tryEnd() throws ParseException {
        except_clause except_clause;
        ArrayList<except_clause> except_clauseList = new ArrayList<except_clause>();
        suite suite = null;
        suite suite1;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPT:
      label_13:
      while (true) {
        except_clause = except_clause();
                                       except_clauseList.add(except_clause);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EXCEPT:
          ;
          break;
        default:
          jj_la1[40] = jj_gen;
          break label_13;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        jj_consume_token(COLON);
        suite = suite();
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
         {if (true) return new tryEnd1(except_clauseList, suite, firstToken.next,token);}
      break;
    case FINALLY:
      jj_consume_token(FINALLY);
      jj_consume_token(COLON);
      suite1 = suite();
         {if (true) return new tryEnd2(suite1, firstToken.next,token);}
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public except_clause except_clause() throws ParseException {
        testcommatest testcommatest = null;
        suite suite;
        Token firstToken=token;
    jj_consume_token(EXCEPT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      testcommatest = testcommatest();
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    suite = suite();
         {if (true) return new except_clause(testcommatest, suite, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public suite suite() throws ParseException {
        simple_stmt simple_stmt;
        Token t;
        ASTStringNode newline;
        ASTStringNode indent;
        stmt stmt;
        ArrayList<stmt> stmtList = new ArrayList<stmt>();
        ASTStringNode dedent;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case PRINT:
    case PASS:
    case BREAK:
    case CONTINUE:
    case RETURN:
    case YIELD:
    case IMPORT:
    case FROM:
    case DEL:
    case RAISE:
    case GLOBAL:
    case EXEC:
    case ASSERT:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      simple_stmt = simple_stmt();
         {if (true) return new suite1(simple_stmt, firstToken.next,token);}
      break;
    case NEWLINE:
      t = jj_consume_token(NEWLINE);
                    newline=new ASTStringNode(t.image,new WToken(t));
                                                                         token_source.expect_indent = true;
      t = jj_consume_token(INDENT);
                                                                                                                        indent=new ASTStringNode(t.image,new WToken(t));
                                                                                                                                                                            token_source.expect_indent = false;
      label_14:
      while (true) {
        stmt = stmt();
                                                                                                                                                                                                                              stmtList.add(stmt);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case LBRACE:
        case LBRACKET:
        case PLUS:
        case MINUS:
        case NOT:
        case NOT_BOOL:
        case LAMBDA:
        case IF:
        case WHILE:
        case FOR:
        case TRY:
        case DEF:
        case CLASS:
        case PRINT:
        case PASS:
        case BREAK:
        case CONTINUE:
        case RETURN:
        case YIELD:
        case IMPORT:
        case FROM:
        case DEL:
        case RAISE:
        case GLOBAL:
        case EXEC:
        case ASSERT:
        case AS:
        case NAME:
        case DECNUMBER:
        case HEXNUMBER:
        case OCTNUMBER:
        case FLOAT:
        case COMPLEX:
        case SINGLE_STRING:
        case SINGLE_STRING2:
        case TRIPLE_STRING:
        case TRIPLE_STRING2:
        case SINGLE_USTRING:
        case SINGLE_USTRING2:
        case TRIPLE_USTRING:
        case TRIPLE_USTRING2:
        case 135:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_14;
        }
      }
      t = jj_consume_token(DEDENT);
                                                                                                                                                                                                                                                                dedent=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new suite2(newline, indent, stmtList, dedent, firstToken.next,token);}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public test test() throws ParseException {
        lambdef lambdef;
        and_test and_test;
        and_test and_test1;
        ArrayList<and_test> and_test1List = new ArrayList<and_test>();
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LAMBDA:
      lambdef = lambdef();
         {if (true) return new test1(lambdef, firstToken.next,token);}
      break;
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      and_test = and_test();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR_BOOL:
          ;
          break;
        default:
          jj_la1[46] = jj_gen;
          break label_15;
        }
        jj_consume_token(OR_BOOL);
        and_test1 = and_test();
                                                       and_test1List.add(and_test1);
      }
         {if (true) return new test2(and_test, and_test1List, firstToken.next,token);}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public and_test and_test() throws ParseException {
        not_test not_test;
        not_test not_test1;
        ArrayList<not_test> not_test1List = new ArrayList<not_test>();
        Token firstToken=token;
    not_test = not_test();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND_BOOL:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_16;
      }
      jj_consume_token(AND_BOOL);
      not_test1 = not_test();
                                                        not_test1List.add(not_test1);
    }
         {if (true) return new and_test(not_test, not_test1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public not_test not_test() throws ParseException {
        not_test not_test;
        comparison comparison;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_BOOL:
      jj_consume_token(NOT_BOOL);
      not_test = not_test();
         {if (true) return new not_test1(not_test, firstToken.next,token);}
      break;
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      comparison = comparison();
         {if (true) return new not_test2(comparison, firstToken.next,token);}
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public comparison comparison() throws ParseException {
        expr expr;
        compEnd compEnd;
        ArrayList<compEnd> compEndList = new ArrayList<compEnd>();
        Token firstToken=token;
    expr = expr();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GREATER:
      case LESS:
      case EQEQUAL:
      case EQLESS:
      case EQGREATER:
      case LESSGREATER:
      case NOTEQUAL:
      case NOT_BOOL:
      case IS:
      case IN:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_17;
      }
      compEnd = compEnd();
                                       compEndList.add(compEnd);
    }
         {if (true) return new comparison(expr, compEndList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public compEnd compEnd() throws ParseException {
        comp_op comp_op;
        expr expr;
        Token firstToken=token;
    comp_op = comp_op();
    expr = expr();
         {if (true) return new compEnd(comp_op, expr, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public comp_op comp_op() throws ParseException {
        Token t;
        ASTStringNode less;
        ASTStringNode greater;
        ASTStringNode eqequal;
        ASTStringNode eqgreater;
        ASTStringNode eqless;
        ASTStringNode lessgreater;
        ASTStringNode notequal;
        ASTStringNode in;
        ASTStringNode in1;
        ASTStringNode is;
        ASTStringNode is1;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LESS:
      t = jj_consume_token(LESS);
                 less=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op1(less, firstToken.next,token);}
      break;
    case GREATER:
      t = jj_consume_token(GREATER);
                    greater=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op2(greater, firstToken.next,token);}
      break;
    case EQEQUAL:
      t = jj_consume_token(EQEQUAL);
                    eqequal=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op3(eqequal, firstToken.next,token);}
      break;
    case EQGREATER:
      t = jj_consume_token(EQGREATER);
                      eqgreater=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op4(eqgreater, firstToken.next,token);}
      break;
    case EQLESS:
      t = jj_consume_token(EQLESS);
                   eqless=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op5(eqless, firstToken.next,token);}
      break;
    case LESSGREATER:
      t = jj_consume_token(LESSGREATER);
                        lessgreater=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op6(lessgreater, firstToken.next,token);}
      break;
    case NOTEQUAL:
      t = jj_consume_token(NOTEQUAL);
                     notequal=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op7(notequal, firstToken.next,token);}
      break;
    case IN:
      t = jj_consume_token(IN);
               in=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op8(in, firstToken.next,token);}
      break;
    case NOT_BOOL:
      jj_consume_token(NOT_BOOL);
      t = jj_consume_token(IN);
                     in1=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op9(in1, firstToken.next,token);}
      break;
    default:
      jj_la1[51] = jj_gen;
      if (jj_2_11(2)) {
        t = jj_consume_token(IS);
                            is=new ASTStringNode(t.image,new WToken(t));
        jj_consume_token(NOT_BOOL);
         {if (true) return new comp_op10(is, firstToken.next,token);}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IS:
          t = jj_consume_token(IS);
               is1=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new comp_op11(is1, firstToken.next,token);}
          break;
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public expr expr() throws ParseException {
        xor_expr xor_expr;
        xor_expr xor_expr1;
        ArrayList<xor_expr> xor_expr1List = new ArrayList<xor_expr>();
        Token firstToken=token;
    xor_expr = xor_expr();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_18;
      }
      jj_consume_token(OR);
      xor_expr1 = xor_expr();
                                                      xor_expr1List.add(xor_expr1);
    }
         {if (true) return new expr(xor_expr, xor_expr1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public xor_expr xor_expr() throws ParseException {
        and_expr and_expr;
        and_expr and_expr1;
        ArrayList<and_expr> and_expr1List = new ArrayList<and_expr>();
        Token firstToken=token;
    and_expr = and_expr();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_19;
      }
      jj_consume_token(XOR);
      and_expr1 = and_expr();
                                                      and_expr1List.add(and_expr1);
    }
         {if (true) return new xor_expr(and_expr, and_expr1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public and_expr and_expr() throws ParseException {
        shift_expr shift_expr;
        shift_expr shift_expr1;
        ArrayList<shift_expr> shift_expr1List = new ArrayList<shift_expr>();
        Token firstToken=token;
    shift_expr = shift_expr();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_20;
      }
      jj_consume_token(AND);
      shift_expr1 = shift_expr();
                                                              shift_expr1List.add(shift_expr1);
    }
         {if (true) return new and_expr(shift_expr, shift_expr1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public shift_expr shift_expr() throws ParseException {
        arith_expr arith_expr;
        shift_exprEnd shift_exprEnd;
        ArrayList<shift_exprEnd> shift_exprEndList = new ArrayList<shift_exprEnd>();
        Token firstToken=token;
    arith_expr = arith_expr();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case RSHIFT:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_21;
      }
      shift_exprEnd = shift_exprEnd();
                                                               shift_exprEndList.add(shift_exprEnd);
    }
         {if (true) return new shift_expr(arith_expr, shift_exprEndList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public shift_exprEnd shift_exprEnd() throws ParseException {
        arith_expr arith_expr;
        arith_expr arith_expr1;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LSHIFT:
      jj_consume_token(LSHIFT);
      arith_expr = arith_expr();
         {if (true) return new shift_exprEnd1(arith_expr, firstToken.next,token);}
      break;
    case RSHIFT:
      jj_consume_token(RSHIFT);
      arith_expr1 = arith_expr();
         {if (true) return new shift_exprEnd2(arith_expr1, firstToken.next,token);}
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public arith_expr arith_expr() throws ParseException {
        term term;
        arith_exprEnd arith_exprEnd;
        ArrayList<arith_exprEnd> arith_exprEndList = new ArrayList<arith_exprEnd>();
        Token firstToken=token;
    term = term();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_22;
      }
      arith_exprEnd = arith_exprEnd();
                                                   arith_exprEndList.add(arith_exprEnd);
    }
         {if (true) return new arith_expr(term, arith_exprEndList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public arith_exprEnd arith_exprEnd() throws ParseException {
        Token t;
        ASTStringNode plus;
        term term;
        ASTStringNode minus;
        term term1;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      t = jj_consume_token(PLUS);
                 plus=new ASTStringNode(t.image,new WToken(t));
      term = term();
         {if (true) return new arith_exprEnd1(plus, term, firstToken.next,token);}
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
                  minus=new ASTStringNode(t.image,new WToken(t));
      term1 = term();
         {if (true) return new arith_exprEnd2(minus, term1, firstToken.next,token);}
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public term term() throws ParseException {
        factor factor;
        termEnd termEnd;
        ArrayList<termEnd> termEndList = new ArrayList<termEnd>();
        Token firstToken=token;
    factor = factor();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case FLOORDIVIDE:
      case MODULO:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_23;
      }
      termEnd = termEnd();
                                           termEndList.add(termEnd);
    }
         {if (true) return new term(factor, termEndList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public termEnd termEnd() throws ParseException {
        factor factor;
        Token t;
        ASTStringNode divide;
        factor factor1;
        ASTStringNode floordivide;
        factor factor2;
        ASTStringNode modulo;
        factor factor3;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
      jj_consume_token(MULTIPLY);
      factor = factor();
         {if (true) return new termEnd1(factor, firstToken.next,token);}
      break;
    case DIVIDE:
      t = jj_consume_token(DIVIDE);
                   divide=new ASTStringNode(t.image,new WToken(t));
      factor1 = factor();
         {if (true) return new termEnd2(divide, factor1, firstToken.next,token);}
      break;
    case FLOORDIVIDE:
      t = jj_consume_token(FLOORDIVIDE);
                        floordivide=new ASTStringNode(t.image,new WToken(t));
      factor2 = factor();
         {if (true) return new termEnd3(floordivide, factor2, firstToken.next,token);}
      break;
    case MODULO:
      t = jj_consume_token(MODULO);
                   modulo=new ASTStringNode(t.image,new WToken(t));
      factor3 = factor();
         {if (true) return new termEnd4(modulo, factor3, firstToken.next,token);}
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public factor factor() throws ParseException {
        Token t;
        ASTStringNode plus;
        factor factor;
        ASTStringNode minus;
        factor factor1;
        ASTStringNode not;
        factor factor2;
        powerfactor powerfactor;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      t = jj_consume_token(PLUS);
                 plus=new ASTStringNode(t.image,new WToken(t));
      factor = factor();
         {if (true) return new factor1(plus, factor, firstToken.next,token);}
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
                  minus=new ASTStringNode(t.image,new WToken(t));
      factor1 = factor();
         {if (true) return new factor2(minus, factor1, firstToken.next,token);}
      break;
    case NOT:
      t = jj_consume_token(NOT);
                not=new ASTStringNode(t.image,new WToken(t));
      factor2 = factor();
         {if (true) return new factor3(not, factor2, firstToken.next,token);}
      break;
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      powerfactor = powerfactor();
         {if (true) return new factor4(powerfactor, firstToken.next,token);}
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public powerfactor powerfactor() throws ParseException {
        atomtrailer atomtrailer;
        factor factor;
        ArrayList<factor> factorList = new ArrayList<factor>();
        Token firstToken=token;
    atomtrailer = atomtrailer();
    label_24:
    while (true) {
      if (jj_2_12(2)) {
        ;
      } else {
        break label_24;
      }
      jj_consume_token(POWER);
      factor = factor();
                                                                     factorList.add(factor);
    }
         {if (true) return new powerfactor(atomtrailer, factorList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public atomtrailer atomtrailer() throws ParseException {
        atom atom;
        atomtrailerEnd atomtrailerEnd;
        ArrayList<atomtrailerEnd> atomtrailerEndList = new ArrayList<atomtrailerEnd>();
        Token firstToken=token;
    atom = atom();
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
      case LBRACKET:
      case DOT:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_25;
      }
      atomtrailerEnd = atomtrailerEnd();
                                                     atomtrailerEndList.add(atomtrailerEnd);
    }
         {if (true) return new atomtrailer(atom, atomtrailerEndList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public atomtrailerEnd atomtrailerEnd() throws ParseException {
        arglist arglist;
        subscriptlist subscriptlist;
        Token t;
        ASTStringNode dot;
        AnyName anyName;
        Token firstToken=token;
    if (jj_2_13(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
         {if (true) return new atomtrailerEnd1(firstToken.next,token);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        arglist = arglist();
        jj_consume_token(RPAREN);
         {if (true) return new atomtrailerEnd2(arglist, firstToken.next,token);}
        break;
      case LBRACKET:
        jj_consume_token(LBRACKET);
        subscriptlist = subscriptlist();
        jj_consume_token(RBRACKET);
         {if (true) return new atomtrailerEnd3(subscriptlist, firstToken.next,token);}
        break;
      case DOT:
        t = jj_consume_token(DOT);
                dot=new ASTStringNode(t.image,new WToken(t));
        anyName = AnyName();
         {if (true) return new atomtrailerEnd4(dot, anyName, firstToken.next,token);}
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public atom atom() throws ParseException {
        SmartTestList smartTestList = null;
        Token t;
        ASTStringNode lbracket;
        listmaker listmaker = null;
        dictmaker dictmaker = null;
        SmartTestList smartTestList1;
        Name name;
        Number number;
        StringNode stringNode;
        StringNode stringNode1;
        ArrayList<StringNode> stringNode1List = new ArrayList<StringNode>();
        Token firstToken=token;
    if (jj_2_14(2)) {
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
         {if (true) return new atom1(firstToken.next,token);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case LBRACE:
        case LBRACKET:
        case PLUS:
        case MINUS:
        case NOT:
        case NOT_BOOL:
        case LAMBDA:
        case AS:
        case NAME:
        case DECNUMBER:
        case HEXNUMBER:
        case OCTNUMBER:
        case FLOAT:
        case COMPLEX:
        case SINGLE_STRING:
        case SINGLE_STRING2:
        case TRIPLE_STRING:
        case TRIPLE_STRING2:
        case SINGLE_USTRING:
        case SINGLE_USTRING2:
        case TRIPLE_USTRING:
        case TRIPLE_USTRING2:
        case 135:
          smartTestList = SmartTestList();
          break;
        default:
          jj_la1[65] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
         {if (true) return new atom2(smartTestList, firstToken.next,token);}
        break;
      case LBRACKET:
        t = jj_consume_token(LBRACKET);
                     lbracket=new ASTStringNode(t.image,new WToken(t));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case LBRACE:
        case LBRACKET:
        case PLUS:
        case MINUS:
        case NOT:
        case NOT_BOOL:
        case LAMBDA:
        case AS:
        case NAME:
        case DECNUMBER:
        case HEXNUMBER:
        case OCTNUMBER:
        case FLOAT:
        case COMPLEX:
        case SINGLE_STRING:
        case SINGLE_STRING2:
        case TRIPLE_STRING:
        case TRIPLE_STRING2:
        case SINGLE_USTRING:
        case SINGLE_USTRING2:
        case TRIPLE_USTRING:
        case TRIPLE_USTRING2:
        case 135:
          listmaker = listmaker();
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
        }
        jj_consume_token(RBRACKET);
         {if (true) return new atom3(lbracket, listmaker, firstToken.next,token);}
        break;
      case LBRACE:
        jj_consume_token(LBRACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case LBRACE:
        case LBRACKET:
        case PLUS:
        case MINUS:
        case NOT:
        case NOT_BOOL:
        case LAMBDA:
        case AS:
        case NAME:
        case DECNUMBER:
        case HEXNUMBER:
        case OCTNUMBER:
        case FLOAT:
        case COMPLEX:
        case SINGLE_STRING:
        case SINGLE_STRING2:
        case TRIPLE_STRING:
        case TRIPLE_STRING2:
        case SINGLE_USTRING:
        case SINGLE_USTRING2:
        case TRIPLE_USTRING:
        case TRIPLE_USTRING2:
        case 135:
          dictmaker = dictmaker();
          break;
        default:
          jj_la1[67] = jj_gen;
          ;
        }
        jj_consume_token(RBRACE);
         {if (true) return new atom4(dictmaker, firstToken.next,token);}
        break;
      case 135:
        jj_consume_token(135);
        smartTestList1 = SmartTestList();
        jj_consume_token(135);
         {if (true) return new atom5(smartTestList1, firstToken.next,token);}
        break;
      case AS:
      case NAME:
        name = Name();
         {if (true) return new atom6(name, firstToken.next,token);}
        break;
      case DECNUMBER:
      case HEXNUMBER:
      case OCTNUMBER:
      case FLOAT:
      case COMPLEX:
        number = Number();
         {if (true) return new atom7(number, firstToken.next,token);}
        break;
      case SINGLE_STRING:
      case SINGLE_STRING2:
      case TRIPLE_STRING:
      case TRIPLE_STRING2:
      case SINGLE_USTRING:
      case SINGLE_USTRING2:
      case TRIPLE_USTRING:
      case TRIPLE_USTRING2:
        stringNode = StringNode();
        label_26:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SINGLE_STRING:
          case SINGLE_STRING2:
          case TRIPLE_STRING:
          case TRIPLE_STRING2:
          case SINGLE_USTRING:
          case SINGLE_USTRING2:
          case TRIPLE_USTRING:
          case TRIPLE_USTRING2:
            ;
            break;
          default:
            jj_la1[68] = jj_gen;
            break label_26;
          }
          stringNode1 = StringNode();
                                                          stringNode1List.add(stringNode1);
        }
         {if (true) return new atom8(stringNode, stringNode1List, firstToken.next,token);}
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public lambdef lambdef() throws ParseException {
        Token t;
        ASTStringNode lambda;
        varargslist varargslist = null;
        test test;
        Token firstToken=token;
    t = jj_consume_token(LAMBDA);
                   lambda=new ASTStringNode(t.image,new WToken(t));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case MULTIPLY:
    case POWER:
    case AS:
    case NAME:
      varargslist = varargslist();
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    test = test();
         {if (true) return new lambdef(lambda, varargslist, test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public subscriptlist subscriptlist() throws ParseException {
        subscript subscript;
        subscript subscript1;
        ArrayList<subscript> subscript1List = new ArrayList<subscript>();
        ASTTextNode text586 = null;
        Token firstToken=token;
    subscript = subscript();
    label_27:
    while (true) {
      if (jj_2_15(2)) {
        ;
      } else {
        break label_27;
      }
      jj_consume_token(COMMA);
      subscript1 = subscript();
                                                                       subscript1List.add(subscript1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                                                text586=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[71] = jj_gen;
      ;
    }
         {if (true) return new subscriptlist(subscript, subscript1List, text586, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public subscript subscript() throws ParseException {
        Token t;
        ASTStringNode dot;
        ASTStringNode dot1;
        ASTStringNode dot2;
        test test;
        slice slice = null;
        slice slice1;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      t = jj_consume_token(DOT);
                dot=new ASTStringNode(t.image,new WToken(t));
      t = jj_consume_token(DOT);
                                                                       dot1=new ASTStringNode(t.image,new WToken(t));
      t = jj_consume_token(DOT);
                                                                                                                               dot2=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new subscript1(dot, dot1, dot2, firstToken.next,token);}
      break;
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      test = test();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        slice = slice();
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
         {if (true) return new subscript2(test, slice, firstToken.next,token);}
      break;
    case COLON:
      slice1 = slice();
         {if (true) return new subscript3(slice1, firstToken.next,token);}
      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public slice slice() throws ParseException {
        ct ct;
        ct ct1 = null;
        Token firstToken=token;
    ct = ct();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      ct1 = ct();
      break;
    default:
      jj_la1[74] = jj_gen;
      ;
    }
         {if (true) return new slice(ct, ct1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public ct ct() throws ParseException {
        test test = null;
        Token firstToken=token;
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case NOT_BOOL:
    case LAMBDA:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      test = test();
      break;
    default:
      jj_la1[75] = jj_gen;
      ;
    }
         {if (true) return new ct(test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public exprlist exprlist() throws ParseException {
        expr expr;
        expr expr1;
        ArrayList<expr> expr1List = new ArrayList<expr>();
        ASTTextNode text587 = null;
        Token firstToken=token;
    expr = expr();
    label_28:
    while (true) {
      if (jj_2_16(2)) {
        ;
      } else {
        break label_28;
      }
      jj_consume_token(COMMA);
      expr1 = expr();
                                                   expr1List.add(expr1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                  text587=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[76] = jj_gen;
      ;
    }
         {if (true) return new exprlist(expr, expr1List, text587, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public SmartTestList SmartTestList() throws ParseException {
        test test;
        test test1;
        ArrayList<test> test1List = new ArrayList<test>();
        ASTTextNode text588 = null;
        Token firstToken=token;
    test = test();
    label_29:
    while (true) {
      if (jj_2_17(2)) {
        ;
      } else {
        break label_29;
      }
      jj_consume_token(COMMA);
      test1 = test();
                                                   test1List.add(test1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                  text588=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[77] = jj_gen;
      ;
    }
         {if (true) return new SmartTestList(test, test1List, text588, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public testlist testlist() throws ParseException {
        test test;
        test test1;
        ArrayList<test> test1List = new ArrayList<test>();
        ASTTextNode text589 = null;
        Token firstToken=token;
    test = test();
    label_30:
    while (true) {
      if (jj_2_18(2)) {
        ;
      } else {
        break label_30;
      }
      jj_consume_token(COMMA);
      test1 = test();
                                                   test1List.add(test1);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                  text589=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
         {if (true) return new testlist(test, test1List, text589, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public dictmaker dictmaker() throws ParseException {
        test test;
        test test1;
        dictInt dictInt;
        ArrayList<dictInt> dictIntList = new ArrayList<dictInt>();
        ASTTextNode text590 = null;
        Token firstToken=token;
    test = test();
    jj_consume_token(COLON);
    test1 = test();
    label_31:
    while (true) {
      if (jj_2_19(2)) {
        ;
      } else {
        break label_31;
      }
      dictInt = dictInt();
                                                                     dictIntList.add(dictInt);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
                                                                                                        text590=new ASTTextNode(",",new WToken(token));
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
         {if (true) return new dictmaker(test, test1, dictIntList, text590, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public dictInt dictInt() throws ParseException {
        test test;
        test test1;
        Token firstToken=token;
    jj_consume_token(COMMA);
    test = test();
    jj_consume_token(COLON);
    test1 = test();
         {if (true) return new dictInt(test, test1, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public listmaker listmaker() throws ParseException {
        test test;
        listmakerEnd listmakerEnd;
        Token firstToken=token;
    test = test();
    listmakerEnd = listmakerEnd();
         {if (true) return new listmaker(test, listmakerEnd, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public listmakerEnd listmakerEnd() throws ParseException {
        list_for list_for;
        ArrayList<list_for> list_forList = new ArrayList<list_for>();
        test test;
        ArrayList<test> testList = new ArrayList<test>();
        ASTTextNode text591 = null;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR:
      label_32:
      while (true) {
        list_for = list_for();
                             list_forList.add(list_for);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
          ;
          break;
        default:
          jj_la1[80] = jj_gen;
          break label_32;
        }
      }
         {if (true) return new listmakerEnd1(list_forList, firstToken.next,token);}
      break;
    default:
      jj_la1[82] = jj_gen;
      label_33:
      while (true) {
        if (jj_2_20(2)) {
          ;
        } else {
          break label_33;
        }
        jj_consume_token(COMMA);
        test = test();
                                      testList.add(test);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
                                                                   text591=new ASTTextNode(",",new WToken(token));
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
         {if (true) return new listmakerEnd2(testList, text591, firstToken.next,token);}
    }
    throw new Error("Missing return statement in function");
  }

  final public list_for list_for() throws ParseException {
        exprlist exprlist;
        SmartTestList smartTestList;
        list_if list_if;
        ArrayList<list_if> list_ifList = new ArrayList<list_if>();
        Token firstToken=token;
    jj_consume_token(FOR);
    exprlist = exprlist();
    jj_consume_token(IN);
    smartTestList = SmartTestList();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_34;
      }
      list_if = list_if();
                                                                                        list_ifList.add(list_if);
    }
         {if (true) return new list_for(exprlist, smartTestList, list_ifList, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public list_if list_if() throws ParseException {
        test test;
        Token firstToken=token;
    jj_consume_token(IF);
    test = test();
         {if (true) return new list_if(test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public classdef classdef() throws ParseException {
        Name name;
        testlist testlist = null;
        suite suite;
        Token firstToken=token;
    jj_consume_token(CLASS);
    name = Name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      testlist = testlist();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[84] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    suite = suite();
         {if (true) return new classdef(name, testlist, suite, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public arglist arglist() throws ParseException {
        normalargs normalargs;
        arglist1End arglist1End = null;
        arglist1EndEnd arglist1EndEnd = null;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case LBRACKET:
    case PLUS:
    case MINUS:
    case NOT:
    case OR_BOOL:
    case AND_BOOL:
    case NOT_BOOL:
    case IS:
    case IN:
    case LAMBDA:
    case IF:
    case ELSE:
    case ELIF:
    case WHILE:
    case FOR:
    case TRY:
    case EXCEPT:
    case DEF:
    case CLASS:
    case FINALLY:
    case PRINT:
    case PASS:
    case BREAK:
    case CONTINUE:
    case RETURN:
    case YIELD:
    case IMPORT:
    case FROM:
    case DEL:
    case RAISE:
    case GLOBAL:
    case EXEC:
    case ASSERT:
    case AS:
    case NAME:
    case DECNUMBER:
    case HEXNUMBER:
    case OCTNUMBER:
    case FLOAT:
    case COMPLEX:
    case SINGLE_STRING:
    case SINGLE_STRING2:
    case TRIPLE_STRING:
    case TRIPLE_STRING2:
    case SINGLE_USTRING:
    case SINGLE_USTRING2:
    case TRIPLE_USTRING:
    case TRIPLE_USTRING2:
    case 135:
      normalargs = normalargs();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        arglist1End = arglist1End();
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
         {if (true) return new arglist1(normalargs, arglist1End, firstToken.next,token);}
      break;
    default:
      jj_la1[86] = jj_gen;
      if (jj_2_21(2)) {
        arglist1EndEnd = arglist1EndEnd();
      } else {
        ;
      }
         {if (true) return new arglist2(arglist1EndEnd, firstToken.next,token);}
    }
    throw new Error("Missing return statement in function");
  }

  final public arglist1End arglist1End() throws ParseException {
        arglist1EndEnd arglist1EndEnd = null;
        Token firstToken=token;
    jj_consume_token(COMMA);
    if (jj_2_22(2)) {
      arglist1EndEnd = arglist1EndEnd();
    } else {
      ;
    }
         {if (true) return new arglist1End(arglist1EndEnd, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public arglist1EndEnd arglist1EndEnd() throws ParseException {
        ExtraArgValueList extraArgValueList;
        ExtraKeywordValueList extraKeywordValueList = null;
        ExtraKeywordValueList extraKeywordValueList1;
        Token firstToken=token;
    if (jj_2_23(2)) {
      extraArgValueList = ExtraArgValueList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        extraKeywordValueList = ExtraKeywordValueList();
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
         {if (true) return new arglist1EndEnd1(extraArgValueList, extraKeywordValueList, firstToken.next,token);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case POWER:
        extraKeywordValueList1 = ExtraKeywordValueList();
         {if (true) return new arglist1EndEnd2(extraKeywordValueList1, firstToken.next,token);}
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public normalargs normalargs() throws ParseException {
        argument argument;
        argument argument1;
        ArrayList<argument> argument1List = new ArrayList<argument>();
        Token firstToken=token;
    argument = argument();
    label_35:
    while (true) {
      if (jj_2_24(2)) {
        ;
      } else {
        break label_35;
      }
      jj_consume_token(COMMA);
      argument1 = argument();
                                                                   argument1List.add(argument1);
    }
         {if (true) return new normalargs(argument, argument1List, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public ExtraArgValueList ExtraArgValueList() throws ParseException {
        test test;
        Token firstToken=token;
    jj_consume_token(MULTIPLY);
    test = test();
         {if (true) return new ExtraArgValueList(test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public ExtraKeywordValueList ExtraKeywordValueList() throws ParseException {
        power power;
        test test;
        Token firstToken=token;
    power = power();
    test = test();
         {if (true) return new ExtraKeywordValueList(power, test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public power power() throws ParseException {
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POWER:
      jj_consume_token(POWER);
         {if (true) return new power1(firstToken.next,token);}
      break;
    case MULTIPLY:
      jj_consume_token(MULTIPLY);
      jj_consume_token(MULTIPLY);
         {if (true) return new power2(firstToken.next,token);}
      break;
    default:
      jj_la1[89] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public argument argument() throws ParseException {
        AnyName anyName = null;
        test test;
        Token firstToken=token;
    if (jj_2_25(2)) {
      anyName = AnyName();
      jj_consume_token(EQUAL);
    } else {
      ;
    }
    test = test();
         {if (true) return new argument(anyName, test, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public Number Number() throws ParseException {
        Token t;
        ASTStringNode hexnumber;
        ASTStringNode octnumber;
        ASTStringNode decnumber;
        ASTStringNode float_kw;
        ASTStringNode complex;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HEXNUMBER:
      t = jj_consume_token(HEXNUMBER);
                      hexnumber=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Number1(hexnumber, firstToken.next,token);}
      break;
    case OCTNUMBER:
      t = jj_consume_token(OCTNUMBER);
                      octnumber=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Number2(octnumber, firstToken.next,token);}
      break;
    case DECNUMBER:
      t = jj_consume_token(DECNUMBER);
                      decnumber=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Number3(decnumber, firstToken.next,token);}
      break;
    case FLOAT:
      t = jj_consume_token(FLOAT);
                  float_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Number4(float_kw, firstToken.next,token);}
      break;
    case COMPLEX:
      t = jj_consume_token(COMPLEX);
                    complex=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Number5(complex, firstToken.next,token);}
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Complex Complex() throws ParseException {
        Token t;
        ASTStringNode float_kw;
        Token firstToken=token;
    t = jj_consume_token(FLOAT);
                  float_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Complex(float_kw, firstToken.next,token);}
    throw new Error("Missing return statement in function");
  }

  final public Name Name() throws ParseException {
        Token t;
        ASTStringNode name;
        ASTStringNode as;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NAME:
      t = jj_consume_token(NAME);
                 name=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Name1(name, firstToken.next,token);}
      break;
    case AS:
      t = jj_consume_token(AS);
               as=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new Name2(as, firstToken.next,token);}
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public StringNode StringNode() throws ParseException {
        Token t;
        ASTStringNode single_string;
        ASTStringNode single_string2;
        ASTStringNode triple_string;
        ASTStringNode triple_string2;
        ASTStringNode single_ustring;
        ASTStringNode single_ustring2;
        ASTStringNode triple_ustring;
        ASTStringNode triple_ustring2;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SINGLE_STRING:
      t = jj_consume_token(SINGLE_STRING);
                          single_string=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode1(single_string, firstToken.next,token);}
      break;
    case SINGLE_STRING2:
      t = jj_consume_token(SINGLE_STRING2);
                           single_string2=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode2(single_string2, firstToken.next,token);}
      break;
    case TRIPLE_STRING:
      t = jj_consume_token(TRIPLE_STRING);
                          triple_string=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode3(triple_string, firstToken.next,token);}
      break;
    case TRIPLE_STRING2:
      t = jj_consume_token(TRIPLE_STRING2);
                           triple_string2=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode4(triple_string2, firstToken.next,token);}
      break;
    case SINGLE_USTRING:
      t = jj_consume_token(SINGLE_USTRING);
                           single_ustring=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode5(single_ustring, firstToken.next,token);}
      break;
    case SINGLE_USTRING2:
      t = jj_consume_token(SINGLE_USTRING2);
                            single_ustring2=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode6(single_ustring2, firstToken.next,token);}
      break;
    case TRIPLE_USTRING:
      t = jj_consume_token(TRIPLE_USTRING);
                           triple_ustring=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode7(triple_ustring, firstToken.next,token);}
      break;
    case TRIPLE_USTRING2:
      t = jj_consume_token(TRIPLE_USTRING2);
                            triple_ustring2=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new StringNode8(triple_ustring2, firstToken.next,token);}
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AnyName AnyName() throws ParseException {
        Token t;
        ASTStringNode name;
        ASTStringNode is;
        ASTStringNode in;
        ASTStringNode lambda;
        ASTStringNode if_kw;
        ASTStringNode else_kw;
        ASTStringNode elif;
        ASTStringNode while_kw;
        ASTStringNode for_kw;
        ASTStringNode try_kw;
        ASTStringNode except;
        ASTStringNode def;
        ASTStringNode class_kw;
        ASTStringNode finally_kw;
        ASTStringNode print;
        ASTStringNode pass;
        ASTStringNode break_kw;
        ASTStringNode continue_kw;
        ASTStringNode return_kw;
        ASTStringNode yield;
        ASTStringNode import_kw;
        ASTStringNode from;
        ASTStringNode del;
        ASTStringNode raise;
        ASTStringNode global;
        ASTStringNode exec;
        ASTStringNode assert_kw;
        ASTStringNode as;
        Token firstToken=token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NAME:
      t = jj_consume_token(NAME);
                 name=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName1(name, firstToken.next,token);}
      break;
    case OR_BOOL:
      jj_consume_token(OR_BOOL);
         {if (true) return new AnyName2(firstToken.next,token);}
      break;
    case AND_BOOL:
      jj_consume_token(AND_BOOL);
         {if (true) return new AnyName3(firstToken.next,token);}
      break;
    case NOT_BOOL:
      jj_consume_token(NOT_BOOL);
         {if (true) return new AnyName4(firstToken.next,token);}
      break;
    case IS:
      t = jj_consume_token(IS);
               is=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName5(is, firstToken.next,token);}
      break;
    case IN:
      t = jj_consume_token(IN);
               in=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName6(in, firstToken.next,token);}
      break;
    case LAMBDA:
      t = jj_consume_token(LAMBDA);
                   lambda=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName7(lambda, firstToken.next,token);}
      break;
    case IF:
      t = jj_consume_token(IF);
               if_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName8(if_kw, firstToken.next,token);}
      break;
    case ELSE:
      t = jj_consume_token(ELSE);
                 else_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName9(else_kw, firstToken.next,token);}
      break;
    case ELIF:
      t = jj_consume_token(ELIF);
                 elif=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName10(elif, firstToken.next,token);}
      break;
    case WHILE:
      t = jj_consume_token(WHILE);
                  while_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName11(while_kw, firstToken.next,token);}
      break;
    case FOR:
      t = jj_consume_token(FOR);
                for_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName12(for_kw, firstToken.next,token);}
      break;
    case TRY:
      t = jj_consume_token(TRY);
                try_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName13(try_kw, firstToken.next,token);}
      break;
    case EXCEPT:
      t = jj_consume_token(EXCEPT);
                   except=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName14(except, firstToken.next,token);}
      break;
    case DEF:
      t = jj_consume_token(DEF);
                def=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName15(def, firstToken.next,token);}
      break;
    case CLASS:
      t = jj_consume_token(CLASS);
                  class_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName16(class_kw, firstToken.next,token);}
      break;
    case FINALLY:
      t = jj_consume_token(FINALLY);
                    finally_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName17(finally_kw, firstToken.next,token);}
      break;
    case PRINT:
      t = jj_consume_token(PRINT);
                  print=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName18(print, firstToken.next,token);}
      break;
    case PASS:
      t = jj_consume_token(PASS);
                 pass=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName19(pass, firstToken.next,token);}
      break;
    case BREAK:
      t = jj_consume_token(BREAK);
                  break_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName20(break_kw, firstToken.next,token);}
      break;
    case CONTINUE:
      t = jj_consume_token(CONTINUE);
                     continue_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName21(continue_kw, firstToken.next,token);}
      break;
    case RETURN:
      t = jj_consume_token(RETURN);
                   return_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName22(return_kw, firstToken.next,token);}
      break;
    case YIELD:
      t = jj_consume_token(YIELD);
                  yield=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName23(yield, firstToken.next,token);}
      break;
    case IMPORT:
      t = jj_consume_token(IMPORT);
                   import_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName24(import_kw, firstToken.next,token);}
      break;
    case FROM:
      t = jj_consume_token(FROM);
                 from=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName25(from, firstToken.next,token);}
      break;
    case DEL:
      t = jj_consume_token(DEL);
                del=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName26(del, firstToken.next,token);}
      break;
    case RAISE:
      t = jj_consume_token(RAISE);
                  raise=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName27(raise, firstToken.next,token);}
      break;
    case GLOBAL:
      t = jj_consume_token(GLOBAL);
                   global=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName28(global, firstToken.next,token);}
      break;
    case EXEC:
      t = jj_consume_token(EXEC);
                 exec=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName29(exec, firstToken.next,token);}
      break;
    case ASSERT:
      t = jj_consume_token(ASSERT);
                   assert_kw=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName30(assert_kw, firstToken.next,token);}
      break;
    case AS:
      t = jj_consume_token(AS);
               as=new ASTStringNode(t.image,new WToken(t));
         {if (true) return new AnyName31(as, firstToken.next,token);}
      break;
    default:
      jj_la1[93] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  final private boolean jj_3R_131() {
    if (jj_3R_140()) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_3R_123()) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_138()) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(CONTINUE)) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_48()) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_73()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_23()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_3R_47()) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(IS)) return true;
    if (jj_scan_token(NOT_BOOL)) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(PASS)) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_3R_47()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(DEL)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(PRINT)) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(PRINT)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(PRINT)) return true;
    if (jj_scan_token(RSHIFT)) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_3R_145()) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(NOT_BOOL)) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) return true;
    }
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_119()) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_3R_125()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_113()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_112()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_3R_136()) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_111()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_110()) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(AS)) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(ASSERT)) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(EXEC)) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(GLOBAL)) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(RAISE)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(DEL)) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(IMPORT)) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(YIELD)) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(LAMBDA)) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(CONTINUE)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(BREAK)) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(PASS)) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_3R_155()) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(PRINT)) return true;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_3R_154()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(FINALLY)) return true;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_scan_token(135)) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(DEF)) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(EXCEPT)) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(TRY)) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(FOR)) return true;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(WHILE)) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(ELIF)) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  final private boolean jj_3R_143() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(ELSE)) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(IF)) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(ASSERT)) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(LAMBDA)) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(IN)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_scan_token(IS)) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_scan_token(NOT_BOOL)) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(AND_BOOL)) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_scan_token(POWER)) return true;
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(OR_BOOL)) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(NAME)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(EXEC)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(MULTIPLY)) return true;
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(GLOBAL)) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_3R_135()) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_scan_token(TRIPLE_USTRING2)) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(TRIPLE_USTRING)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_scan_token(SINGLE_USTRING2)) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(SINGLE_USTRING)) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_scan_token(TRIPLE_STRING2)) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_scan_token(TRIPLE_STRING)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_scan_token(SINGLE_STRING2)) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(SINGLE_STRING)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(AS)) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(NAME)) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) return true;
    }
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(FROM)) return true;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(IMPORT)) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(COMPLEX)) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_scan_token(DECNUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_scan_token(OCTNUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_scan_token(HEXNUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_3R_153()) return true;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_50()) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_25()) jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(MULTIPLY)) return true;
    if (jj_scan_token(MULTIPLY)) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_scan_token(POWER)) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_scan_token(RAISE)) return true;
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) return true;
    }
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_3R_144()) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(YIELD)) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_3R_52()) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_137()) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(RETURN)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(MULTIPLY)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  public PythonParserTokenManager token_source;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[94];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x30540040,0x30540040,0x40040000,0x2000000,0x2000000,0x40000,0x40000000,0x0,0x40000,0x2000000,0x30540000,0x1000000,0x30540000,0x0,0x0,0x2000000,0x0,0x2000000,0x2000000,0x0,0x30540000,0x30540000,0x2000000,0x2000000,0x0,0x2000000,0x2000000,0x40000000,0x0,0x4000000,0x0,0x2000000,0x0,0x2000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30540000,0x30540000,0x30540040,0x0,0x30540000,0x0,0x30540000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000000,0x30000000,0xc0000000,0xc0000000,0x30540000,0x4440000,0x4440000,0x30540000,0x30540000,0x30540000,0x0,0x540000,0x40040000,0x2000000,0x8000000,0x3c540000,0x8000000,0x30540000,0x2000000,0x2000000,0x2000000,0x2000000,0x0,0x2000000,0x0,0x0,0x40000,0x2000000,0x30540000,0x2000000,0x40000000,0x40000000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x80000020,0x80000020,0x2,0x0,0x0,0x0,0x2,0x200,0x0,0x0,0x80000020,0x0,0x80000020,0x200,0x1ffe0000,0x0,0x0,0x0,0x0,0x0,0x80000020,0x80000020,0x0,0x0,0x0,0x0,0x0,0xe0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000020,0x80000020,0x80000020,0x20000000,0x80000020,0x40000000,0x80000020,0x8001fc00,0x8001fc00,0x0,0x80,0x40,0x100,0xc,0xc,0x0,0x0,0x11,0x11,0x20,0x0,0x0,0x80000020,0x80000020,0x80000020,0x0,0x0,0x2,0x0,0x0,0x80000020,0x0,0x80000020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0000020,0x0,0x2,0x2,0x0,0x0,0x0,0xe0000000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0xefffedcc,0xefffedcc,0xc000000,0x0,0x0,0xc000000,0x0,0x0,0xc000000,0x0,0xefffedcc,0x0,0xefffe004,0x0,0x0,0x0,0x2000,0x0,0x0,0x478000,0xec000004,0xec000004,0x0,0x0,0x180000,0x0,0x0,0xfffffff,0x4000000,0x0,0x4000000,0x0,0x2,0x0,0x0,0xdc8,0x20,0x10,0x10,0x10,0x200,0x10,0x1200,0xec000004,0xefffedcc,0xefffe004,0x0,0xec000004,0x0,0xec000000,0x3,0x2,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xec000000,0x0,0x0,0xec000004,0xec000004,0xec000004,0x0,0xec000000,0xc000000,0x0,0x0,0xec000004,0x0,0xec000004,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x8,0x0,0x0,0xefffffff,0x0,0x0,0x0,0xe0000000,0xc000000,0x0,0xfffffff,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0xff003,0xff003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff003,0x0,0xff003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff003,0xff003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff003,0xff003,0xff003,0x0,0xff003,0x0,0xff003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff003,0x0,0x0,0xff003,0xff003,0xff003,0xff000,0xff003,0x0,0x0,0x0,0xff003,0x0,0xff003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff003,0x0,0x0,0x0,0x3,0x0,0xff000,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x80,0x80,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x80,0x80,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[25];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public PythonParser(CharStream stream) {
    token_source = new PythonParserTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public PythonParser(PythonParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(PythonParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 94; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[136];
    for (int i = 0; i < 136; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 94; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 136; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 25; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
