// Original file:/home/abdulaziz/Desktop/BerkeleyDb/javaFiles/base_x/com/sleepycat/je/dbi/CursorImpl.java
namespace com.sleepycat.je.dbi;
class CursorImpl {
    static class SearchMode {
        public static final SearchMode SET = new SearchMode(true, false, "SET");
        public static final SearchMode BOTH = new SearchMode(true, true, "BOTH");
        public static final SearchMode SET_RANGE = new SearchMode(false, false, "SET_RANGE");
        public static final SearchMode BOTH_RANGE = new SearchMode(false, true, "BOTH_RANGE");
        private boolean exactSearch;
        private boolean dataSearch;
        private String name;
        private SearchMode(boolean exactSearch, boolean dataSearch, String name) {
            this.exactSearch = exactSearch;
            this.dataSearch = dataSearch;
            this.name = "SearchMode." + name;
        }
        /** 
         * Returns true when the key or key/data search is exact, i.e., for SET
         * and BOTH.
         */
        public final boolean isExactSearch() {
            return exactSearch;
        }
        /** 
         * Returns true when the data value is included in the search, i.e., for
         * BOTH and BOTH_RANGE.
         */
        public final boolean isDataSearch() {
            return dataSearch;
        }
        public String toString() {
            return name;
        }
    }
    static class KeyChangeStatus {
        /** 
         * Operation status;
         */
        public OperationStatus status;
        /** 
         * Whether the operation moved to a new key.
         */
        public boolean keyChange;
        public KeyChangeStatus(OperationStatus status, boolean keyChange) {
            this.status = status;
            this.keyChange = keyChange;
        }
    }
    static class CursorImpl_latchBIN {
        CursorImpl_latchBIN(CursorImpl _this) {
            this._this = _this;
        }
        BIN execute() throws DatabaseException {
           // try {
                Label244: //this.hook244();
 //                   Label245: //this.hook245();
//                    throw new ReturnObject(_this.bin);
 //               Label244_1: throw ReturnHack.returnObject;
 //           }
 //           catch (ReturnObject r) {
  //              return (BIN) r.value;
     //       }

	        return null;
        }
        protected CursorImpl _this;
        protected BIN waitingOn;
        
    }
    static class CursorImpl_latchDBIN {
        CursorImpl_latchDBIN(CursorImpl _this) {
            this._this = _this;
        }
        DBIN execute() throws DatabaseException {
  //          try {
                Label246:; //this.hook246();
                Label247: ;
                Label246_1: ;
//                throw new ReturnObject(_this.dupBin);

//throw ReturnHack.returnObject;
        //    }
      //      catch (ReturnObject r) {
                return null; //(DBIN) r.value;
    //        }
        }
        protected CursorImpl _this;
        protected BIN waitingOn;
 
    }
    static class CursorImpl_lockNextKeyForInsert {
        CursorImpl_lockNextKeyForInsert(CursorImpl _this, DatabaseEntry key, DatabaseEntry data) {
            this._this = _this;
            this.key = key;
            this.data = data;
        }
        void execute() throws DatabaseException {
            tempKey = new DatabaseEntry(key.getData(), key.getOffset(), key.getSize());
            tempData = new DatabaseEntry(data.getData(), data.getOffset(), data.getSize());
            tempKey.setPartial(0, 0, true);
            tempData.setPartial(0, 0, true);
            lockedNextKey = false;
            searchMode = _this.database.getSortedDuplicates() ? SearchMode.BOTH_RANGE : SearchMode.SET_RANGE;
            Label248: //this.hook248();
                searchResult = _this.searchAndPosition(tempKey, tempData, searchMode, LockType.RANGE_INSERT);
            if ((searchResult & _this.FOUND) != 0 && (searchResult & _this.FOUND_LAST) == 0) {
                {}
                if ((searchResult & _this.EXACT_KEY) != 0) {
                    status = _this.getNext(tempKey, tempData, LockType.RANGE_INSERT, true, true);
                } else {
                    status = _this.getNextNoDup(tempKey, tempData, LockType.RANGE_INSERT, true, true);
                }
                if (status == OperationStatus.SUCCESS) {
                    lockedNextKey = true;
                }
                Label249: ;//this.hook249();
            }
            Label248_1:
                if (!lockedNextKey) {
                    _this.lockEofNode(LockType.RANGE_INSERT);
                }
        }
        protected CursorImpl _this;
        protected DatabaseEntry key;
        protected DatabaseEntry data;
        protected DatabaseEntry tempKey;
        protected DatabaseEntry tempData;
        protected boolean lockedNextKey;
        protected SearchMode searchMode;
        protected boolean latched;
        protected int searchResult;
        protected OperationStatus status;

    }
    static class CursorImpl_getNextDuplicate {
        CursorImpl_getNextDuplicate(CursorImpl _this, DatabaseEntry foundKey, DatabaseEntry foundData, LockType lockType, boolean forward, boolean alreadyLatched) {
            this._this = _this;
            this.foundKey = foundKey;
            this.foundData = foundData;
            this.lockType = lockType;
            this.forward = forward;
            this.alreadyLatched = alreadyLatched;
        }
        OperationStatus execute() throws DatabaseException {
           // try {
                assert _this.assertCursorState(true): _this.dumpToString(true);
                Label250: //this.hook250();
                    try {
                        while (_this.dupBin != null) {
                            Label251: //this.hook251();
                                Label279: //this.hook279();
                                if ((forward && ++_this.dupIndex < _this.dupBin.getNEntries()) || (!forward && --_this.dupIndex > -1)) {
                                    ret = OperationStatus.SUCCESS;
                                    if (foundKey != null) {
                                        ret = _this.getCurrentAlreadyLatched(foundKey, foundData, lockType, forward);
                                    } else {
                                        Label252: ;//this.hook252();
                                    }
                                    if (ret == OperationStatus.SUCCESS) {
                                        _this.incrementLNCount();
                                        return ret;
                                    } else {
                                        Label253: //this.hook253();
                                            if (_this.dupBinToBeRemoved != null) {
                                                _this.flushDBINToBeRemoved();
                                            }
                                        continue;
                                    }
                                }
                            else {
                                if (_this.dupBinToBeRemoved != null) {
                                    _this.flushDBINToBeRemoved();
                                }
                                _this.dupBinToBeRemoved = _this.dupBin;
                                _this.dupBin = null;
                                Label255: //this.hook255();
                                    Label275: //this.hook275();
                                    Label254: //this.hook254();
                                    {}
                                if (forward) {
                                    newDupBin = (DBIN) _this.database.getTree().getNextBin(_this.dupBinToBeRemoved, true);
                                } else {
                                    newDupBin = (DBIN) _this.database.getTree().getPrevBin(_this.dupBinToBeRemoved, true);
                                }
                                if (newDupBin == null) {
                                    return OperationStatus.NOTFOUND;
                                } else {
                                    if (forward) {
                                        _this.dupIndex = -1;
                                    } else {
                                        _this.dupIndex = newDupBin.getNEntries();
                                    }
                                    _this.addCursor(newDupBin);
                                    _this.dupBin = newDupBin;
                                    Label256: ;//this.hook256();
                                }
                            }
                        }
                    }
                finally {
                    Label257: //this.hook257();
                        if (_this.dupBinToBeRemoved != null) {
                            _this.flushDBINToBeRemoved();
                        }
                }
                return OperationStatus.NOTFOUND;
         //   } catch (ReturnObject r) {
          //      return (OperationStatus) r.value;
           // }
        }
        protected CursorImpl _this;
        protected DatabaseEntry foundKey;
        protected DatabaseEntry foundData;
        protected LockType lockType;
        protected boolean forward;
        protected boolean alreadyLatched;
        protected OperationStatus ret;
        protected TreeWalkerStatsAccumulator treeStatsAccumulator;
        protected DIN duplicateRoot;
        protected DupCountLN dcl;
        protected DBIN newDupBin;
       
    }
    static class CursorImpl_fetchCurrent {
        CursorImpl_fetchCurrent(CursorImpl _this, DatabaseEntry foundKey, DatabaseEntry foundData, LockType lockType, boolean first) {
            this._this = _this;
            this.foundKey = foundKey;
            this.foundData = foundData;
            this.lockType = lockType;
            this.first = first;
        }
        OperationStatus execute() throws DatabaseException {
            try {
                treeStatsAccumulator = _this.getTreeStatsAccumulator();
                duplicateFetch = _this.setTargetBin();
                if (_this.targetBin == null) {
                    return OperationStatus.NOTFOUND;
                }
                Label259: //this.hook259();
                    n = null;
                if (_this.targetIndex < 0 || _this.targetIndex >= _this.targetBin.getNEntries() || _this.targetBin.isEntryKnownDeleted(_this.targetIndex)) {} else {
                    if (_this.targetBin.isEntryPendingDeleted(_this.targetIndex)) {
                        Label280: ;//this.hook280();
                    }
                    Label260: ; //this.hook260();
                    n = _this.targetBin.fetchTarget(_this.targetIndex);
                    Label260_1: ; //this.hook260();

                }
                if (n == null) {
                    if (treeStatsAccumulator != null) {
                        treeStatsAccumulator.incrementDeletedLNCount();
                    }
                    Label261: //this.hook261();
                        return OperationStatus.KEYEMPTY;
                }
                _this.addCursor(_this.targetBin);
                if (n.containsDuplicates()) {
                    assert!duplicateFetch;
                    duplicateRoot = (DIN) n;
                    Label262: //this.hook262();
                        if (_this.positionFirstOrLast(first, duplicateRoot)) {
                            Label263:; //this.hook263();
                            _this.fetchCurrent(foundKey, foundData, lockType, first);
                            Label263_1:; // end of hook263();
                        }
                    else {
                        return OperationStatus.NOTFOUND;
                    }
                }
                ln = (LN) n;
                assert TestHookExecute.doHookIfSet(_this.testHook);
                lockResult = _this.lockLN(ln, lockType);
                Label258: ; //this.hook258();
                ln = lockResult.getLN();
                lnData = (ln != null) ? ln.getData() : null;
                if (ln == null || lnData == null) {
                    if (treeStatsAccumulator != null) {
                        treeStatsAccumulator.incrementDeletedLNCount();
                    }
                    throw new ReturnObject(OperationStatus.KEYEMPTY);
                }
                duplicateFetch = _this.setTargetBin();
                if (duplicateFetch) {
                    if (foundData != null) {
                        _this.setDbt(foundData, _this.targetBin.getKey(_this.targetIndex));
                    }
                    if (foundKey != null) {
                        _this.setDbt(foundKey, _this.targetBin.getDupKey());
                    }
                } else {
                    if (foundData != null) {
                        _this.setDbt(foundData, lnData);
                    }
                    if (foundKey != null) {
                        _this.setDbt(foundKey, _this.targetBin.getKey(_this.targetIndex));
                    }
                }
Label258_1: ;
                return OperationStatus.SUCCESS;


            } catch (ReturnObject r) {
                return (OperationStatus) r.value;
            }
        }
        protected CursorImpl _this;
        protected DatabaseEntry foundKey;
        protected DatabaseEntry foundData;
        protected LockType lockType;
        protected boolean first;
        protected TreeWalkerStatsAccumulator treeStatsAccumulator;
        protected boolean duplicateFetch;
        protected Node n;
        protected EnvironmentImpl envImpl;
        protected DIN duplicateRoot;
        protected LN ln;
        protected LockResult lockResult;
        protected byte[] lnData;

    }
}
