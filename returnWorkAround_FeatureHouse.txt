Derivative_Statistics_MemoryBudget/com/sleepycat/je/util/DbCacheSize.java:        throw new ReturnVoid();
Latches/com/sleepycat/je/tree/IN.java:      throw new ReturnBoolean(false);
Latches/com/sleepycat/je/dbi/CursorImpl.java:      throw new ReturnObject(null);
Latches/com/sleepycat/je/dbi/CursorImpl.java:      throw new ReturnObject(null);
MemoryBudget/com/sleepycat/je/util/DbCacheSize.java: catch (      ReturnVoid r) {
Statistics/com/sleepycat/je/dbi/CursorImpl.java:        throw new ReturnObject(OperationStatus.NOTFOUND);
EnvironmentLocking/com/sleepycat/je/cleaner/Cleaner.java:      throw new ReturnVoid();
CPTime/com/sleepycat/je/recovery/Checkpointer.java:          throw new ReturnBoolean(true);
CPTime/com/sleepycat/je/recovery/Checkpointer.java:          throw new ReturnBoolean(false);
INCompressor/com/sleepycat/je/incomp/INCompressor.java: catch (    ReturnObject r) {
INCompressor/com/sleepycat/je/incomp/INCompressor.java:        throw new ReturnObject(null);
INCompressor/com/sleepycat/je/incomp/INCompressor.java:        throw new ReturnObject(duplicateBin);
INCompressor/com/sleepycat/je/incomp/INCompressor.java:        throw new ReturnObject(bin);
INCompressor/com/sleepycat/je/incomp/INCompressor.java:      throw new ReturnObject(null);
base/com/sleepycat/je/cleaner/FileProcessor.java: catch (    ReturnVoid r) {
base/com/sleepycat/je/cleaner/FileProcessor.java: catch (    ReturnObject r) {
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnVoid();
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnObject(null);
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnObject(null);
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnObject(in);
base/com/sleepycat/je/cleaner/UtilizationProfile.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/cleaner/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/UtilizationProfile.java:    throw new ReturnBoolean(false);
base/com/sleepycat/je/cleaner/Cleaner.java: catch (    ReturnVoid r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnVoid r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(wrl.doWork(root));
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(wrl.doWork(root));
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnVoid();
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(searchDupTreeForDupCountLNParent(location,mainKey,childNode));
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnBoolean(searchDupTreeByNodeId(location,childNode,ln,searchDupTree,updateGeneration));
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnBoolean(searchDupTreeForDBIN(location,dupKey,(DIN)childNode,ln,findDeletedEntries,indicateIfExact,exactSearch,splitsAllowed,updateGeneration));
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnObject(null);
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnObject(null);
base/com/sleepycat/je/tree/Tree.java:            throw new ReturnObject(null);
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnObject((BIN)nextIN);
base/com/sleepycat/je/tree/Tree.java:            throw new ReturnObject((BIN)ret);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnObject(parent);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnObject(parent);
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(parent);
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(rootIN);
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnBoolean(insertDuplicate(key,bin,ln,logManager,inMemoryINs,cursor,lnLock,allowDuplicates));
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnBoolean(rootIN.validateSubtreeBeforeDelete(index));
base/com/sleepycat/je/tree/IN.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/IN.java: * Returns whether any resident children are not LNs (are INs).
base/com/sleepycat/je/tree/IN.java: catch (      ReturnBoolean r) {
base/com/sleepycat/je/tree/IN.java:        throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/IN.java:        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/sleepycat/je/tree/IN.java: catch (      ReturnBoolean r) {
base/com/sleepycat/je/tree/IN.java:        throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/IN.java:        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/sleepycat/je/tree/IN.java:        throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/IN.java:    throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/BIN.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/BIN.java:      throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/BIN.java:        throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/BIN.java:        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/sleepycat/je/tree/BIN.java:        throw new ReturnBoolean(true);
base/com/sleepycat/je/dbi/PreloadLSNTreeWalker.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:      throw new ReturnObject(null);
base/com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:    throw new ReturnObject(in.fetchTarget(index));
base/com/sleepycat/je/dbi/MemoryBudget.java: * Returns Runtime.maxMemory(), accounting for a MacOS bug. May return
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnInt r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnInt r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(_this.bin);
base/com/sleepycat/je/dbi/CursorImpl.java: catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(_this.dupBin);
base/com/sleepycat/je/dbi/CursorImpl.java: catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.KEYEMPTY);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.SUCCESS);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(_this.fetchCurrent(foundKey,foundData,lockType,first));
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt(0);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt(dupCountLN.getDupCount());
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt(1);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.NOTFOUND);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.NOTFOUND);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.SUCCESS);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(fetchCurrent(foundKey,foundData,lockType,first));
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(null);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(null);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(ln);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnBoolean(found);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt((foundSomething ? FOUND : 0) | (foundExactKey ? EXACT_KEY : 0) | (foundExactData ? EXACT_DATA : 0)| (foundLast ? FOUND_LAST : 0));
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnInt r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnInt r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(attemptLockInternal(nodeId,locker,type,nonBlockingRequest,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(makeTimeoutMsgInternal(lockOrTxn,locker,nodeId,type,grantType,useLock,timeout,start,now,database));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(releaseAndFindNotifyTargetsInternal(nodeId,lock,locker,removeFromLocker,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(isLockedInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(isOwnerInternal(nodeId,locker,type,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(isWaiterInternal(nodeId,locker,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnInt(nWaitersInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnInt(nOwnersInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(getWriteOwnerLockerInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(validateOwnershipInternal(nodeId,locker,type,flushFromWaiters,mb,lockTableIndex));
base/com/sleepycat/je/log/entry/NodeLogEntry.java: * Returns the node ID.  This value is redundant with the main item (Node)
base/com/sleepycat/je/log/SyncedLogManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/log/SyncedLogManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/log/SyncedLogManager.java:    throw new ReturnObject(logInternal(item,isProvisional,flushRequired,forceNewLogFile,oldNodeLsn,marshallOutsideLatch,marshalledBuffer,tracker));
base/com/sleepycat/je/log/SyncedLogManager.java:    throw new ReturnObject(getUnflushableTrackedSummaryInternal(file));
base/com/sleepycat/je/log/FileManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/log/FileManager.java:      throw new ReturnObject(fileHandle);
base/com/sleepycat/je/recovery/Checkpointer.java: catch (      ReturnBoolean r) {
base/com/sleepycat/je/recovery/Checkpointer.java:      throw new ReturnBoolean(false);
CPBytes/com/sleepycat/je/recovery/Checkpointer.java:          throw new ReturnBoolean(true);
CPBytes/com/sleepycat/je/recovery/Checkpointer.java:          throw new ReturnBoolean(false);
FileHandleCache/FileManaget2.txt:	} catch (ReturnObject r) {
FileHandleCache/FileManaget2.txt:									throw new ReturnObject(fileHandle);}
FileHandleCache/FileManaget.txt:	} catch (ReturnObject r) {
FileHandleCache/FileManaget.txt:	    throw new ReturnObject(fileHandle);
Derivative_Statistics_MemoryBudget/originalFiles/DbCacheSize.java:        throw new ReturnVoid();
Derivative_Statistics_MemoryBudget/ump_inner/Derivative_Statistics_MemoryBudget_DbCacheSize_inner.ump:          return; //throw new ReturnVoid();
Derivative_Statistics_MemoryBudget/com/sleepycat/je/util/DbCacheSize.java://         throw new ReturnVoid();
Latches/umpilif/Latches_IN.ump:        throw new ReturnBoolean(false);
Latches/umpilif/Latches_CursorImpl.ump:                    throw new ReturnObject(fetchCurrent(foundKey, foundData, lockType, first));
Latches/originalFiles/IN.java:      throw new ReturnBoolean(false);
Latches/originalFiles/CursorImpl.java:      throw new ReturnObject(null);
Latches/originalFiles/CursorImpl.java:      throw new ReturnObject(null);
Latches/ump_inner/Latches_CursorImpl_inner.ump:        throw new ReturnObject(null);
Latches/ump_inner/Latches_CursorImpl_inner.ump:        throw new ReturnObject(null);
Latches/com/sleepycat/je/tree/IN.java:      throw new ReturnBoolean(false);
Latches/com/sleepycat/je/dbi/CursorImpl.java://       throw new ReturnObject(null);
Latches/com/sleepycat/je/dbi/CursorImpl.java://       throw new ReturnObject(null);
Evictor/umpilif/Evictor_IN.ump:     * Returns whether this node can itself be evicted.  This is faster than (getEvictionType() == MAY_EVICT_NODE) and is used by the evictor after a node has been selected, to check that it is still evictable.
MemoryBudget/umpilif/MemoryBudget_TrackedFileSummary.ump:     * Return the total memory size for this object.  We only bother to budget obsolete detail, not the overhead for this object, for two reasons: 1) The number of these objects is very small, and 2) unit tests disable detail tracking as a way to prevent budget adjustments here.
MemoryBudget/originalFiles/DbCacheSize.java: catch (      ReturnVoid r) {
MemoryBudget/com/sleepycat/je/util/DbCacheSize.java://  catch (      ReturnVoid r) {
Statistics/originalFiles/CursorImpl.java:        throw new ReturnObject(OperationStatus.NOTFOUND);
Statistics/ump_inner/Statistics_CursorImpl_inner.ump://          throw new ReturnObject(OperationStatus.NOTFOUND);
Statistics/ump_inner/Statistics_CursorImpl_inner.ump:          throw new ReturnObject(OperationStatus.NOTFOUND);
Statistics/com/sleepycat/je/dbi/CursorImpl.java://         throw new ReturnObject(OperationStatus.NOTFOUND);
EnvironmentLocking/umpilif/EnvironmentLocking_FileManager.ump:     * Lock the environment. Return true if the lock was acquired. If exclusive is false, then this implements a single writer, multiple reader lock. If exclusive is true, then implement an exclusive lock. There is a lock file and there are two regions of the lock file: byte 0, and byte 1. Byte 0 is the exclusive writer process area of the lock file. If an environment is opened for write, then it attempts to take an exclusive write lock on byte 0. Byte 1 is the shared reader process area of the lock file. If an environment is opened for read-only, then it attempts to take a shared lock on byte 1. This is how we implement single writer, multi reader semantics. The cleaner, each time it is invoked, attempts to take an exclusive lock on byte 1. The owning process already either has an exclusive lock on byte 0, or a shared lock on byte 1. This will necessarily conflict with any shared locks on byte 1, even if it's in the same process and there are no other holders of that shared lock. So if there is only one read-only process, it will have byte 1 for shared access, and the cleaner can not run in it because it will attempt to get an exclusive lock on byte 1 (which is already locked for shared access by itself). If a write process comes along and tries to run the cleaner, it will attempt to get an exclusive lock on byte 1. If there are no other reader processes (with shared locks on byte 1), and no other writers (which are running cleaners on with exclusive locks on byte 1), then the cleaner will run.
EnvironmentLocking/umpilif/EnvironmentLocking_Cleaner.ump:	    return; //throw new ReturnVoid();
EnvironmentLocking/com/sleepycat/je/cleaner/Cleaner.java:      throw new ReturnVoid();
CPTime/originalFiles/Checkpointer.java:          throw new ReturnBoolean(true);
CPTime/originalFiles/Checkpointer.java:          throw new ReturnBoolean(false);
CPTime/ump_inner/CPTime_Checkpointer_inner.ump:     return true;//throw new ReturnBoolean(true);
CPTime/ump_inner/CPTime_Checkpointer_inner.ump:     return false;//throw new ReturnBoolean(false);
CPTime/ump_inner/CPTime_Checkpointer_inner.ump:    return false; //throw new ReturnBoolean(false); // added from hook542() 
CPTime/com/sleepycat/je/recovery/Checkpointer.java://           throw new ReturnBoolean(true);
CPTime/com/sleepycat/je/recovery/Checkpointer.java://           throw new ReturnBoolean(false);
com/sleepycat/je/cleaner/FileProcessor.java:                throw new ReturnVoid();
com/sleepycat/je/cleaner/FileProcessor.java:        } catch (ReturnVoid r) {
com/sleepycat/je/cleaner/FileProcessor.java:                throw new ReturnObject(null);
com/sleepycat/je/cleaner/FileProcessor.java:                throw new ReturnObject(null);
com/sleepycat/je/cleaner/FileProcessor.java:                throw new ReturnObject( in );
com/sleepycat/je/cleaner/FileProcessor.java:        } catch (ReturnObject r) {
com/sleepycat/je/cleaner/FileProcessor.java:     * Check if the cloned IN is the same node as the root in tree. Return the real root if it is, null otherwise. If non-null is returned, the returned IN (the root) is latched -- caller is responsible for unlatching it.
com/sleepycat/je/cleaner/FileProcessor.java:     * throw new ReturnObject(null);
com/sleepycat/je/cleaner/FileProcessor.java:     * throw new ReturnObject(null);
com/sleepycat/je/cleaner/FileProcessor.java:     * throw new ReturnObject(in);
com/sleepycat/je/cleaner/UtilizationProfile.java:   * Returns the stored/packed obsolete offsets and the tracked obsolete offsets for the given file.  The tracked summary object returned can be used to test for obsolete offsets that are being added during cleaning by other threads participating in lazy migration.  The caller must call TrackedFileSummary.setAllowFlush(true) when cleaning is complete. This method performs eviction and is not synchronized.
com/sleepycat/je/cleaner/UtilizationProfile.java:					throw new ReturnBoolean(true);
com/sleepycat/je/cleaner/UtilizationProfile.java:					throw new ReturnBoolean(true);
com/sleepycat/je/cleaner/UtilizationProfile.java:					throw new ReturnBoolean(true);
com/sleepycat/je/cleaner/UtilizationProfile.java:			throw new ReturnBoolean(false);
com/sleepycat/je/cleaner/UtilizationProfile.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/cleaner/UtilizationProfile.java:   * throw new ReturnBoolean(true);
com/sleepycat/je/cleaner/UtilizationProfile.java:   * throw new ReturnBoolean(true);
com/sleepycat/je/cleaner/UtilizationProfile.java:   * throw new ReturnBoolean(true);
com/sleepycat/je/cleaner/UtilizationProfile.java:   * throw new ReturnBoolean(false);
com/sleepycat/je/cleaner/Cleaner.java:	    throw new ReturnVoid();
com/sleepycat/je/cleaner/Cleaner.java:	} catch (ReturnVoid r) {
com/sleepycat/je/cleaner/Cleaner.java:   * Returns a copy of the cleaned and processed files at the time a checkpoint starts. <p> If non-null is returned, the checkpoint should flush an extra level, and addCheckpointedFiles() should be called when the checkpoint is complete. </p>
com/sleepycat/je/cleaner/TrackedFileSummary.java:   * Return the total memory size for this object.  We only bother to budget obsolete detail, not the overhead for this object, for two reasons: 1) The number of these objects is very small, and 2) unit tests disable detail tracking as a way to prevent budget adjustments here.
com/sleepycat/je/tree/Tree.java:            throw new ReturnObject(wrl.doWork(root));
com/sleepycat/je/tree/Tree.java:        catch (ReturnObject r) {
com/sleepycat/je/tree/Tree.java:            throw new ReturnObject(wrl.doWork(root))
com/sleepycat/je/tree/Tree.java:        catch (ReturnObject r) {
com/sleepycat/je/tree/Tree.java:                throw new ReturnVoid();
com/sleepycat/je/tree/Tree.java:        } catch (ReturnVoid r) {
com/sleepycat/je/tree/Tree.java:                                throw new ReturnBoolean(searchDupTreeForDupCountLNParent(location, mainKey, childNode));
com/sleepycat/je/tree/Tree.java:                                        throw new ReturnBoolean(searchDupTreeForDBIN(location, dupKey, (DIN) childNode, ln,
com/sleepycat/je/tree/Tree.java:        } catch (ReturnBoolean r) {
com/sleepycat/je/tree/Tree.java:                throw new ReturnBoolean(true);
com/sleepycat/je/tree/Tree.java:                throw new ReturnBoolean(false);
com/sleepycat/je/tree/Tree.java:        } catch (ReturnBoolean r) {
com/sleepycat/je/tree/Tree.java:                        throw new ReturnObject(null);
com/sleepycat/je/tree/Tree.java:                        throw new ReturnObject(null);
com/sleepycat/je/tree/Tree.java:                            throw new ReturnObject(null);
com/sleepycat/je/tree/Tree.java:                        throw new ReturnObject((BIN) nextIN);
com/sleepycat/je/tree/Tree.java:                            throw new ReturnObject((BIN) ret);
com/sleepycat/je/tree/Tree.java:            catch (ReturnObject r) {
com/sleepycat/je/tree/Tree.java:   * @return - the Node that matches the criteria, if any. This is the nodethat is farthest down the tree with a match. Returns null if the root is null. Node is latched (unless it's null) and must be unlatched by the caller. Only IN's and BIN's are returned, not LN's. In a NORMAL search, It is the caller's responsibility to do the findEntry() call on the key and BIN to locate the entry that matches key. The return value node is latched upon return and it is the caller's responsibility to unlatch it.
com/sleepycat/je/tree/Tree.java:                    throw new ReturnObject(parent);
com/sleepycat/je/tree/Tree.java:                    throw new ReturnObject(parent);
com/sleepycat/je/tree/Tree.java:            throw new ReturnObject(parent);
com/sleepycat/je/tree/Tree.java:        } catch (ReturnObject r) {
com/sleepycat/je/tree/Tree.java:            throw new ReturnObject(rootIN);
com/sleepycat/je/tree/Tree.java:        catch (ReturnObject r) {
com/sleepycat/je/tree/Tree.java:                throw new ReturnBoolean(true);
com/sleepycat/je/tree/Tree.java:                    throw new ReturnBoolean(true);
com/sleepycat/je/tree/Tree.java:        } catch (ReturnBoolean r) {
com/sleepycat/je/tree/Tree.java:                        throw new ReturnBoolean(false);
com/sleepycat/je/tree/Tree.java:        } catch (ReturnBoolean r) {
com/sleepycat/je/tree/Tree.java:            Label715_1: throw new ReturnBoolean(rootIN.validateSubtreeBeforeDelete(index));
com/sleepycat/je/tree/Tree.java:        catch (ReturnBoolean r) {
com/sleepycat/je/tree/FileSummaryLN.java:   * Returns true if the given key for this LN is a String file number key. For the old version of the LN there will be a single record per file. If this is a version 0 log entry, the key is a string.  However, such an LN may be migrated by the cleaner, in which case the version will be 1 or greater [#13061].  In the latter case, we can distinguish a string key by: 1) If the key is not 8 bytes long, it has to be a string key. 2) If the key is 8 bytes long, but bytes[4] is ascii "0" to "9", then it must be a string key.  bytes[4] to bytes[7] are a sequence number that is the number of log entries counted.  For this number to be greater than 0x30000000, the binary value of 4 digits starting with ascii "0", over 400 million log entries would have to occur in a single file; this should never happen. Note that having to rely on method (2) is unlikely.  A string key will only be 8 bytes if the file number reach 8 decimal digits (10,000,000 to 99,999,999).  This is a very large file number and unlikely to have occurred using JE 1.7.1 or earlier. In summary, the only time the algorithm here could fail is if there were more than 400 million log entries per file, and more than 10 million were written with JE 1.7.1 or earlier.
com/sleepycat/je/tree/IN.java:				throw new ReturnBoolean(true);
com/sleepycat/je/tree/IN.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/tree/IN.java:   * Returns whether any resident children are not LNs (are INs).
com/sleepycat/je/tree/IN.java:   * throw new ReturnBoolean(true);
com/sleepycat/je/tree/IN.java:   * Returns whether this node can itself be evicted.  This is faster than (getEvictionType() == MAY_EVICT_NODE) and is used by the evictor after a node has been selected, to check that it is still evictable.
com/sleepycat/je/tree/IN.java:  		        throw new ReturnBoolean(true);
com/sleepycat/je/tree/IN.java:  		        throw new ReturnBoolean(child != null && child.isValidForDelete());
com/sleepycat/je/tree/IN.java:     catch (      ReturnBoolean r) {
com/sleepycat/je/tree/IN.java:  						    throw new ReturnBoolean(false);
com/sleepycat/je/tree/IN.java:  						    throw new ReturnBoolean(child != null && child.isValidForDelete());
com/sleepycat/je/tree/IN.java:  						    throw new ReturnBoolean(true);
com/sleepycat/je/tree/IN.java:     catch (      ReturnBoolean r) {
com/sleepycat/je/tree/IN.java:        throw new ReturnBoolean(false);
com/sleepycat/je/tree/BIN.java:						throw new ReturnBoolean(false);
com/sleepycat/je/tree/BIN.java:					throw new ReturnBoolean(false);
com/sleepycat/je/tree/BIN.java:							throw new ReturnBoolean(child != null && child.isValidForDelete());
com/sleepycat/je/tree/BIN.java:									throw new ReturnBoolean(true);
com/sleepycat/je/tree/BIN.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/tree/BIN.java:   * throw new ReturnBoolean(false);
com/sleepycat/je/tree/BIN.java:   * throw new ReturnBoolean(false);
com/sleepycat/je/tree/BIN.java:   * throw new ReturnBoolean(child != null && child.isValidForDelete());
com/sleepycat/je/tree/BIN.java:   * throw new ReturnBoolean(true);
com/sleepycat/je/util/DbCacheSize.java:            throw new ReturnVoid();
com/sleepycat/je/util/DbCacheSize.java:     catch (      ReturnVoid r) {
com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:					throw new ReturnObject(null);
com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:			throw new ReturnObject(in.fetchTarget(inEntry.index));
com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:  public void catch(ReturnObject r){
com/sleepycat/je/dbi/MemoryBudget.java:   * Returns Runtime.maxMemory(), accounting for a MacOS bug. May return Long.MAX_VALUE if there is no inherent limit. Used by unit tests as well as by this class.
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(OperationStatus.NOTFOUND);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(OperationStatus.NOTFOUND);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(OperationStatus.SUCCESS);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(fetchCurrent(foundKey, foundData, lockType, first));
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(null);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(null);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnObject(ln);
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnInt(0);
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnInt(dupCountLN.getDupCount());
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnInt(1);
com/sleepycat/je/dbi/CursorImpl.java:        } catch (ReturnInt r) {
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnObject(OperationStatus.NOTFOUND);
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnObject(OperationStatus.NOTFOUND);
com/sleepycat/je/dbi/CursorImpl.java:				    //throw new ReturnObject(OperationStatus.SUCCESS);
com/sleepycat/je/dbi/CursorImpl.java:        } catch (ReturnObject r) {
com/sleepycat/je/dbi/CursorImpl.java:                    throw new ReturnObject(fetchCurrent(foundKey, foundData, lockType, first));
com/sleepycat/je/dbi/CursorImpl.java:        } catch (ReturnObject r) {
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnObject(null);
com/sleepycat/je/dbi/CursorImpl.java:				        throw new ReturnObject(null);
com/sleepycat/je/dbi/CursorImpl.java:				    //throw new ReturnObject(ln);
com/sleepycat/je/dbi/CursorImpl.java:        } catch (ReturnObject r) {
com/sleepycat/je/dbi/CursorImpl.java:        //throw new ReturnBoolean(found);
com/sleepycat/je/dbi/CursorImpl.java:catch (ReturnBoolean r) {
com/sleepycat/je/dbi/CursorImpl.java:				catch (ReturnInt r) {
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnInt(0);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnInt(dupCountLN.getDupCount());
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnInt(1);
com/sleepycat/je/dbi/CursorImpl.java:   * throw new ReturnBoolean(found);
com/sleepycat/je/dbi/CursorImpl.java:        throw new ReturnInt((foundSomething ? FOUND : 0) | (foundExactKey ? EXACT_KEY : 0) |
com/sleepycat/je/dbi/CursorImpl.java:    throw new ReturnObject(_this.bin);
com/sleepycat/je/dbi/CursorImpl.java:          throw new ReturnObject(null);
com/sleepycat/je/dbi/CursorImpl.java:     catch (ReturnObject r) {
com/sleepycat/je/dbi/CursorImpl.java:    throw new ReturnObject(_this.dupBin);
com/sleepycat/je/dbi/CursorImpl.java:          throw new ReturnObject(null);
com/sleepycat/je/dbi/CursorImpl.java:     catch (ReturnObject r) {
com/sleepycat/je/dbi/CursorImpl.java:            throw new ReturnObject(OperationStatus.NOTFOUND);
com/sleepycat/je/dbi/CursorImpl.java:     catch (ReturnObject r) {
com/sleepycat/je/dbi/CursorImpl.java:         throw new ReturnObject(_this.fetchCurrent(foundKey,foundData,lockType,first));
com/sleepycat/je/dbi/CursorImpl.java:    throw new ReturnObject(OperationStatus.KEYEMPTY);
com/sleepycat/je/dbi/CursorImpl.java:    throw new ReturnObject(OperationStatus.SUCCESS);
com/sleepycat/je/dbi/CursorImpl.java:     catch (ReturnObject r) {
com/sleepycat/je/incomp/INCompressor.java:				throw new ReturnObject(null);
com/sleepycat/je/incomp/INCompressor.java:				throw new ReturnObject(duplicateBin);
com/sleepycat/je/incomp/INCompressor.java:				throw new ReturnObject(bin);
com/sleepycat/je/incomp/INCompressor.java:					throw new ReturnObject(null);
com/sleepycat/je/incomp/INCompressor.java:	} catch (ReturnObject r) {
com/sleepycat/je/txn/Locker.java:   * Returns whether this locker can share locks with the given locker. <p>All lockers share locks with a BuddyLocker whose buddy is this locker.  To support BuddyLocker when overriding this method, always return true if this implementation (super.sharesLocksWith(...)) returns true.</p>
com/sleepycat/je/txn/SyncedLockManager.java:			throw new ReturnObject(attemptLockInternal(nodeId, locker, type, nonBlockingRequest, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnObject r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnObject(makeTimeoutMsgInternal(lockOrTxn, locker, nodeId, type, grantType, useLock, timeout,	start, now, database));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnObject r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnObject(		releaseAndFindNotifyTargetsInternal(nodeId, lock, locker, removeFromLocker, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnObject r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnBoolean(isLockedInternal(nodeId, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnBoolean(isOwnerInternal(nodeId, locker, type, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnBoolean(isWaiterInternal(nodeId, locker, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnInt(nWaitersInternal(nodeId, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnInt r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnInt(nOwnersInternal(nodeId, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnInt r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnObject(getWriteOwnerLockerInternal(nodeId, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnObject r) {
com/sleepycat/je/txn/SyncedLockManager.java:	throw new ReturnBoolean(validateOwnershipInternal(nodeId, locker, type, flushFromWaiters, mb, lockTableIndex));
com/sleepycat/je/txn/SyncedLockManager.java:	} catch (ReturnBoolean r) {
com/sleepycat/je/txn/TxnManager.java:   * Returns whether there are any active serializable transactions, excluding the transaction given (if non-null). This is intentionally returned without latching, since latching would not make the act of reading an integer more atomic than it already is.
com/sleepycat/je/utilint/TinyHashSet.java:    public boolean setReturnedTheObject(boolean aReturnedTheObject)
com/sleepycat/je/utilint/TinyHashSet.java:    public boolean getReturnedTheObject()
com/sleepycat/je/utilint/TinyHashSet.java:              "returnedTheObject" + ":" + getReturnedTheObject()+ "]" + System.getProperties().getProperty("line.separator") +
com/sleepycat/je/log/SyncedLogManager.java:	} catch (ReturnObject r) {
com/sleepycat/je/log/SyncedLogManager.java:	} catch (ReturnObject r) {
com/sleepycat/je/log/SyncedLogManager.java:    throw new ReturnObject(getUnflushableTrackedSummaryInternal(file));
com/sleepycat/je/log/FileManager.java:                throw new ReturnObject(fileHandle);
com/sleepycat/je/log/FileManager.java:        } catch (ReturnObject r) {
com/sleepycat/je/log/FileManager.java:   * throw new ReturnObject(fileHandle);
com/sleepycat/je/log/FileManager.java:   * Lock the environment. Return true if the lock was acquired. If exclusive is false, then this implements a single writer, multiple reader lock. If exclusive is true, then implement an exclusive lock. There is a lock file and there are two regions of the lock file: byte 0, and byte 1. Byte 0 is the exclusive writer process area of the lock file. If an environment is opened for write, then it attempts to take an exclusive write lock on byte 0. Byte 1 is the shared reader process area of the lock file. If an environment is opened for read-only, then it attempts to take a shared lock on byte 1. This is how we implement single writer, multi reader semantics. The cleaner, each time it is invoked, attempts to take an exclusive lock on byte 1. The owning process already either has an exclusive lock on byte 0, or a shared lock on byte 1. This will necessarily conflict with any shared locks on byte 1, even if it's in the same process and there are no other holders of that shared lock. So if there is only one read-only process, it will have byte 1 for shared access, and the cleaner can not run in it because it will attempt to get an exclusive lock on byte 1 (which is already locked for shared access by itself). If a write process comes along and tries to run the cleaner, it will attempt to get an exclusive lock on byte 1. If there are no other reader processes (with shared locks on byte 1), and no other writers (which are running cleaners on with exclusive locks on byte 1), then the cleaner will run.
com/sleepycat/je/recovery/Checkpointer.java:  								  throw new ReturnBoolean(false); // add hook542
com/sleepycat/je/recovery/Checkpointer.java:  		          throw new ReturnBoolean(true);
com/sleepycat/je/recovery/Checkpointer.java:  						      throw new ReturnBoolean(false);
com/sleepycat/je/recovery/Checkpointer.java:              throw new ReturnBoolean(true);
com/sleepycat/je/recovery/Checkpointer.java:  								    throw new ReturnBoolean(false);
com/sleepycat/je/recovery/Checkpointer.java:  						    throw new ReturnBoolean(false); // added from hook542() 
com/sleepycat/je/recovery/Checkpointer.java:     catch (      ReturnBoolean r) {
com/sleepycat/bind/serial/SerialBinding.java:   * Returns the class loader to be used during deserialization, or null if a default class loader should be used. The default implementation of this method returns null. <p> This method may be overriden to return a dynamically determined class loader. For example, <code>Thread.currentThread().getContextClassLoader()</code> could be called to use the context class loader for the curren thread. Or <code>getBaseClass().getClassLoader()</code> could be called to use the class loader for the base class, assuming that a base class has been specified. </p> <p> If this method returns null, a default class loader will be used as determined by the <code>java.io.ObjectInputStream.resolveClass</code> method. </p>
INCompressor/umpilif/INCompressor_INCompressor.ump:				throw new ReturnObject(null);
INCompressor/umpilif/INCompressor_INCompressor.ump:				throw new ReturnObject(duplicateBin);
INCompressor/umpilif/INCompressor_INCompressor.ump:				throw new ReturnObject(bin);
INCompressor/umpilif/INCompressor_INCompressor.ump:					throw new ReturnObject(null);
INCompressor/umpilif/INCompressor_INCompressor.ump:	} catch (ReturnObject r) {
INCompressor/originalFiles/INCompressor.java: catch (    ReturnObject r) {
INCompressor/originalFiles/INCompressor.java:        throw new ReturnObject(null);
INCompressor/originalFiles/INCompressor.java:        throw new ReturnObject(duplicateBin);
INCompressor/originalFiles/INCompressor.java:        throw new ReturnObject(bin);
INCompressor/originalFiles/INCompressor.java:      throw new ReturnObject(null);
INCompressor/com/sleepycat/je/incomp/INCompressor.java: catch (    ReturnObject r) {
INCompressor/com/sleepycat/je/incomp/INCompressor.java:        throw new ReturnObject(null);
INCompressor/com/sleepycat/je/incomp/INCompressor.java:        throw new ReturnObject(duplicateBin);
INCompressor/com/sleepycat/je/incomp/INCompressor.java:        throw new ReturnObject(bin);
INCompressor/com/sleepycat/je/incomp/INCompressor.java:      throw new ReturnObject(null);
base/com/originalFiles/Tree.java: catch (    ReturnObject r) {
base/com/originalFiles/Tree.java: catch (    ReturnObject r) {
base/com/originalFiles/Tree.java: catch (    ReturnVoid r) {
base/com/originalFiles/Tree.java: catch (    ReturnBoolean r) {
base/com/originalFiles/Tree.java: catch (    ReturnBoolean r) {
base/com/originalFiles/Tree.java: catch (    ReturnObject r) {
base/com/originalFiles/Tree.java: catch (    ReturnObject r) {
base/com/originalFiles/Tree.java: catch (    ReturnObject r) {
base/com/originalFiles/Tree.java: catch (    ReturnBoolean r) {
base/com/originalFiles/Tree.java: catch (    ReturnBoolean r) {
base/com/originalFiles/Tree.java: catch (    ReturnBoolean r) {
base/com/originalFiles/Tree.java:    throw new ReturnObject(wrl.doWork(root));
base/com/originalFiles/Tree.java:    throw new ReturnObject(wrl.doWork(root));
base/com/originalFiles/Tree.java:      throw new ReturnVoid();
base/com/originalFiles/Tree.java:      throw new ReturnBoolean(searchDupTreeForDupCountLNParent(location,mainKey,childNode));
base/com/originalFiles/Tree.java:          throw new ReturnBoolean(searchDupTreeByNodeId(location,childNode,ln,searchDupTree,updateGeneration));
base/com/originalFiles/Tree.java:          throw new ReturnBoolean(searchDupTreeForDBIN(location,dupKey,(DIN)childNode,ln,findDeletedEntries,indicateIfExact,exactSearch,splitsAllowed,updateGeneration));
base/com/originalFiles/Tree.java:      throw new ReturnBoolean(true);
base/com/originalFiles/Tree.java:      throw new ReturnBoolean(false);
base/com/originalFiles/Tree.java:          throw new ReturnObject(null);
base/com/originalFiles/Tree.java:          throw new ReturnObject(null);
base/com/originalFiles/Tree.java:            throw new ReturnObject(null);
base/com/originalFiles/Tree.java:          throw new ReturnObject((BIN)nextIN);
base/com/originalFiles/Tree.java:            throw new ReturnObject((BIN)ret);
base/com/originalFiles/Tree.java:        throw new ReturnObject(parent);
base/com/originalFiles/Tree.java:        throw new ReturnObject(parent);
base/com/originalFiles/Tree.java:    throw new ReturnObject(parent);
base/com/originalFiles/Tree.java:    throw new ReturnObject(rootIN);
base/com/originalFiles/Tree.java:      throw new ReturnBoolean(true);
base/com/originalFiles/Tree.java:        throw new ReturnBoolean(true);
base/com/originalFiles/Tree.java:        throw new ReturnBoolean(insertDuplicate(key,bin,ln,logManager,inMemoryINs,cursor,lnLock,allowDuplicates));
base/com/originalFiles/Tree.java:        throw new ReturnBoolean(false);
base/com/originalFiles/Tree.java:    throw new ReturnBoolean(rootIN.validateSubtreeBeforeDelete(index));
base/com/originalFiles/PreloadLSNTreeWalker.java: catch (    ReturnObject r) {
base/com/originalFiles/PreloadLSNTreeWalker.java:      throw new ReturnObject(null);
base/com/originalFiles/PreloadLSNTreeWalker.java:    throw new ReturnObject(in.fetchTarget(index));
base/com/originalFiles/IN.java: catch (    ReturnBoolean r) {
base/com/originalFiles/IN.java: * Returns whether any resident children are not LNs (are INs).
base/com/originalFiles/IN.java: catch (      ReturnBoolean r) {
base/com/originalFiles/IN.java:        throw new ReturnBoolean(true);
base/com/originalFiles/IN.java:        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/originalFiles/IN.java: catch (      ReturnBoolean r) {
base/com/originalFiles/IN.java:        throw new ReturnBoolean(false);
base/com/originalFiles/IN.java:        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/originalFiles/IN.java:        throw new ReturnBoolean(true);
base/com/originalFiles/IN.java:    throw new ReturnBoolean(true);
base/com/originalFiles/MemoryBudget.java: * Returns Runtime.maxMemory(), accounting for a MacOS bug. May return
base/com/originalFiles/Checkpointer.java: catch (      ReturnBoolean r) {
base/com/originalFiles/Checkpointer.java:      throw new ReturnBoolean(false);
base/com/originalFiles/FileProcessor.java: catch (    ReturnVoid r) {
base/com/originalFiles/FileProcessor.java: catch (    ReturnObject r) {
base/com/originalFiles/FileProcessor.java:      throw new ReturnVoid();
base/com/originalFiles/FileProcessor.java:      throw new ReturnObject(null);
base/com/originalFiles/FileProcessor.java:      throw new ReturnObject(null);
base/com/originalFiles/FileProcessor.java:      throw new ReturnObject(in);
base/com/originalFiles/CursorImpl.java: catch (    ReturnInt r) {
base/com/originalFiles/CursorImpl.java: catch (    ReturnObject r) {
base/com/originalFiles/CursorImpl.java: catch (    ReturnObject r) {
base/com/originalFiles/CursorImpl.java: catch (    ReturnObject r) {
base/com/originalFiles/CursorImpl.java: catch (    ReturnBoolean r) {
base/com/originalFiles/CursorImpl.java: catch (    ReturnInt r) {
base/com/originalFiles/CursorImpl.java: catch (ReturnObject r) {
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(_this.bin);
base/com/originalFiles/CursorImpl.java: catch (ReturnObject r) {
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(_this.dupBin);
base/com/originalFiles/CursorImpl.java: catch (ReturnObject r) {
base/com/originalFiles/CursorImpl.java: catch (ReturnObject r) {
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(OperationStatus.KEYEMPTY);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(OperationStatus.SUCCESS);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(_this.fetchCurrent(foundKey,foundData,lockType,first));
base/com/originalFiles/CursorImpl.java:throw new ReturnInt(0);
base/com/originalFiles/CursorImpl.java:throw new ReturnInt(dupCountLN.getDupCount());
base/com/originalFiles/CursorImpl.java:throw new ReturnInt(1);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(OperationStatus.NOTFOUND);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(OperationStatus.NOTFOUND);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(OperationStatus.SUCCESS);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(fetchCurrent(foundKey,foundData,lockType,first));
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(null);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(null);
base/com/originalFiles/CursorImpl.java:throw new ReturnObject(ln);
base/com/originalFiles/CursorImpl.java:throw new ReturnBoolean(found);
base/com/originalFiles/CursorImpl.java:throw new ReturnInt((foundSomething ? FOUND : 0) | (foundExactKey ? EXACT_KEY : 0) | (foundExactData ? EXACT_DATA : 0)| (foundLast ? FOUND_LAST : 0));
base/com/originalFiles/FileManager.java: catch (    ReturnObject r) {
base/com/originalFiles/FileManager.java:      throw new ReturnObject(fileHandle);
base/com/originalFiles/UtilizationProfile.java: catch (    ReturnBoolean r) {
base/com/originalFiles/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/originalFiles/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/originalFiles/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/originalFiles/UtilizationProfile.java:    throw new ReturnBoolean(false);
base/com/originalFiles/Cleaner.java: catch (    ReturnVoid r) {
base/com/ump_static/Checkpointer_static.ump:   //catch (ReturnBoolean r) {    return r.value;}
base/com/ump_static/Checkpointer_static.ump:  //  throw new ReturnBoolean(false);
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(_this.bin);
base/com/ump_static/CursorImpl_static.ump:   catch (ReturnObject r) {
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(_this.bin);
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(_this.dupBin);
base/com/ump_static/CursorImpl_static.ump:   catch (ReturnObject r) {
base/com/ump_static/CursorImpl_static.ump://  throw new ReturnObject(_this.dupBin);
base/com/ump_static/CursorImpl_static.ump:   catch (ReturnObject r) {
base/com/ump_static/CursorImpl_static.ump:       throw new ReturnObject(_this.fetchCurrent(foundKey,foundData,lockType,first));
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(OperationStatus.KEYEMPTY);
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(OperationStatus.SUCCESS);
base/com/ump_static/CursorImpl_static.ump:   catch (ReturnObject r) {
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(OperationStatus.KEYEMPTY);
base/com/ump_static/CursorImpl_static.ump:  throw new ReturnObject(OperationStatus.SUCCESS);
base/com/ump_static/CursorImpl_static.ump: // throw new ReturnObject(_this.fetchCurrent(foundKey,foundData,lockType,first));
base/com/ump_static/IN_static.ump:		        throw new ReturnBoolean(true);
base/com/ump_static/IN_static.ump:		        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/ump_static/IN_static.ump:   catch (      ReturnBoolean r) {
base/com/ump_static/IN_static.ump:          throw new ReturnBoolean(true);
base/com/ump_static/IN_static.ump:          throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/ump_static/IN_static.ump:						    throw new ReturnBoolean(false);
base/com/ump_static/IN_static.ump:						    throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/ump_static/IN_static.ump:						    throw new ReturnBoolean(true);
base/com/ump_static/IN_static.ump:   catch (      ReturnBoolean r) {
base/com/ump_static/IN_static.ump:          throw new ReturnBoolean(false);
base/com/ump_static/IN_static.ump:          throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/ump_static/IN_static.ump:          throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/FileProcessor.java: catch (    ReturnVoid r) {
base/com/sleepycat/je/cleaner/FileProcessor.java: catch (    ReturnObject r) {
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnVoid();
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnObject(null);
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnObject(null);
base/com/sleepycat/je/cleaner/FileProcessor.java:      throw new ReturnObject(in);
base/com/sleepycat/je/cleaner/UtilizationProfile.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/cleaner/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/UtilizationProfile.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/cleaner/UtilizationProfile.java:    throw new ReturnBoolean(false);
base/com/sleepycat/je/cleaner/Cleaner.java: catch (    ReturnVoid r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnVoid r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnObject r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(wrl.doWork(root));
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(wrl.doWork(root));
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnVoid();
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(searchDupTreeForDupCountLNParent(location,mainKey,childNode));
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnBoolean(searchDupTreeByNodeId(location,childNode,ln,searchDupTree,updateGeneration));
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnBoolean(searchDupTreeForDBIN(location,dupKey,(DIN)childNode,ln,findDeletedEntries,indicateIfExact,exactSearch,splitsAllowed,updateGeneration));
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnObject(null);
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnObject(null);
base/com/sleepycat/je/tree/Tree.java:            throw new ReturnObject(null);
base/com/sleepycat/je/tree/Tree.java:          throw new ReturnObject((BIN)nextIN);
base/com/sleepycat/je/tree/Tree.java:            throw new ReturnObject((BIN)ret);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnObject(parent);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnObject(parent);
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(parent);
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnObject(rootIN);
base/com/sleepycat/je/tree/Tree.java:      throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnBoolean(insertDuplicate(key,bin,ln,logManager,inMemoryINs,cursor,lnLock,allowDuplicates));
base/com/sleepycat/je/tree/Tree.java:        throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/Tree.java:    throw new ReturnBoolean(rootIN.validateSubtreeBeforeDelete(index));
base/com/sleepycat/je/tree/IN.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/IN.java: * Returns whether any resident children are not LNs (are INs).
base/com/sleepycat/je/tree/IN.java://  catch (      ReturnBoolean r) {
base/com/sleepycat/je/tree/IN.java://         throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/IN.java://         throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/sleepycat/je/tree/IN.java://  catch (      ReturnBoolean r) {
base/com/sleepycat/je/tree/IN.java://         throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/IN.java://         throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/sleepycat/je/tree/IN.java://         throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/IN.java:    throw new ReturnBoolean(true);
base/com/sleepycat/je/tree/BIN.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/tree/BIN.java:      throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/BIN.java:        throw new ReturnBoolean(false);
base/com/sleepycat/je/tree/BIN.java:        throw new ReturnBoolean(child != null && child.isValidForDelete());
base/com/sleepycat/je/tree/BIN.java:        throw new ReturnBoolean(true);
base/com/sleepycat/je/dbi/PreloadLSNTreeWalker.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:      throw new ReturnObject(null);
base/com/sleepycat/je/dbi/PreloadLSNTreeWalker.java:    throw new ReturnObject(in.fetchTarget(index));
base/com/sleepycat/je/dbi/MemoryBudget.java: * Returns Runtime.maxMemory(), accounting for a MacOS bug. May return
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnInt r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/dbi/CursorImpl.java: catch (    ReturnInt r) {
base/com/sleepycat/je/dbi/CursorImpl.java://  catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java:// throw new ReturnObject(_this.bin);
base/com/sleepycat/je/dbi/CursorImpl.java://  catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java:// throw new ReturnObject(_this.dupBin);
base/com/sleepycat/je/dbi/CursorImpl.java://  catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java://  catch (ReturnObject r) {
base/com/sleepycat/je/dbi/CursorImpl.java:// throw new ReturnObject(OperationStatus.KEYEMPTY);
base/com/sleepycat/je/dbi/CursorImpl.java:// throw new ReturnObject(OperationStatus.SUCCESS);
base/com/sleepycat/je/dbi/CursorImpl.java:// throw new ReturnObject(_this.fetchCurrent(foundKey,foundData,lockType,first));
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt(0);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt(dupCountLN.getDupCount());
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt(1);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.NOTFOUND);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.NOTFOUND);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(OperationStatus.SUCCESS);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(fetchCurrent(foundKey,foundData,lockType,first));
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(null);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(null);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnObject(ln);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnBoolean(found);
base/com/sleepycat/je/dbi/CursorImpl.java:throw new ReturnInt((foundSomething ? FOUND : 0) | (foundExactKey ? EXACT_KEY : 0) | (foundExactData ? EXACT_DATA : 0)| (foundLast ? FOUND_LAST : 0));
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnInt r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnInt r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/txn/SyncedLockManager.java: catch (    ReturnBoolean r) {
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(attemptLockInternal(nodeId,locker,type,nonBlockingRequest,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(makeTimeoutMsgInternal(lockOrTxn,locker,nodeId,type,grantType,useLock,timeout,start,now,database));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(releaseAndFindNotifyTargetsInternal(nodeId,lock,locker,removeFromLocker,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(isLockedInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(isOwnerInternal(nodeId,locker,type,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(isWaiterInternal(nodeId,locker,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnInt(nWaitersInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnInt(nOwnersInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnObject(getWriteOwnerLockerInternal(nodeId,lockTableIndex));
base/com/sleepycat/je/txn/SyncedLockManager.java:    throw new ReturnBoolean(validateOwnershipInternal(nodeId,locker,type,flushFromWaiters,mb,lockTableIndex));
base/com/sleepycat/je/log/entry/NodeLogEntry.java: * Returns the node ID.  This value is redundant with the main item (Node)
base/com/sleepycat/je/log/SyncedLogManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/log/SyncedLogManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/log/SyncedLogManager.java:    throw new ReturnObject(logInternal(item,isProvisional,flushRequired,forceNewLogFile,oldNodeLsn,marshallOutsideLatch,marshalledBuffer,tracker));
base/com/sleepycat/je/log/SyncedLogManager.java:    throw new ReturnObject(getUnflushableTrackedSummaryInternal(file));
base/com/sleepycat/je/log/FileManager.java: catch (    ReturnObject r) {
base/com/sleepycat/je/log/FileManager.java:      throw new ReturnObject(fileHandle);
base/com/sleepycat/je/recovery/Checkpointer.java://  catch (      ReturnBoolean r) {
base/com/sleepycat/je/recovery/Checkpointer.java://       throw new ReturnBoolean(false);
base/umplific/CursorImpl.ump:				        throw new ReturnInt(0);
base/umplific/CursorImpl.ump:				        throw new ReturnInt(dupCountLN.getDupCount());
base/umplific/CursorImpl.ump:				        throw new ReturnInt(1);
base/umplific/CursorImpl.ump:        } catch (ReturnInt r) {
base/umplific/CursorImpl.ump:				        throw new ReturnObject(OperationStatus.NOTFOUND);
base/umplific/CursorImpl.ump:				        throw new ReturnObject(OperationStatus.NOTFOUND);
base/umplific/CursorImpl.ump:				    //throw new ReturnObject(OperationStatus.SUCCESS);
base/umplific/CursorImpl.ump:        } catch (ReturnObject r) {
base/umplific/CursorImpl.ump:        } catch (ReturnObject r) {
base/umplific/CursorImpl.ump:				        throw new ReturnObject(null);
base/umplific/CursorImpl.ump:				        throw new ReturnObject(null);
base/umplific/CursorImpl.ump:				    //throw new ReturnObject(ln);
base/umplific/CursorImpl.ump:        } catch (ReturnObject r) {
base/umplific/CursorImpl.ump:        //throw new ReturnBoolean(found);
base/umplific/CursorImpl.ump:catch (ReturnBoolean r) {
base/umplific/CursorImpl.ump:				catch (ReturnInt r) {
base/umplific/CursorImpl.ump:            throw new ReturnInt(0);
base/umplific/CursorImpl.ump:            throw new ReturnInt(dupCountLN.getDupCount());
base/umplific/CursorImpl.ump:            throw new ReturnInt(1);
base/umplific/CursorImpl.ump:            throw new ReturnObject(OperationStatus.NOTFOUND);
base/umplific/CursorImpl.ump:            throw new ReturnObject(OperationStatus.NOTFOUND);
base/umplific/CursorImpl.ump:        throw new ReturnObject(OperationStatus.SUCCESS);
base/umplific/CursorImpl.ump: //       throw new ReturnObject(fetchCurrent(foundKey, foundData, lockType, first));
base/umplific/CursorImpl.ump:            throw new ReturnObject(null);
base/umplific/CursorImpl.ump:            throw new ReturnObject(null);
base/umplific/CursorImpl.ump:        throw new ReturnObject(ln);
base/umplific/CursorImpl.ump:        throw new ReturnBoolean(found);
base/umplific/CursorImpl.ump:        throw new ReturnInt((foundSomething ? FOUND : 0) | (foundExactKey ? EXACT_KEY : 0) |
base/umplific/NodeLogEntry.ump://     * Returns the node ID.  This value is redundant with the main item (Node) of a log entry.  It is returned separately so that it can be obtained when the entry's main //item (Node) is not loaded.  Partial loading is an optimization for recovery.
base/umplific/SyncedLogManager.ump:	} catch (ReturnObject r) {
base/umplific/SyncedLogManager.ump:	} catch (ReturnObject r) {
base/umplific/SyncedLogManager.ump:	throw new ReturnObject(getUnflushableTrackedSummaryInternal(file));
base/umplific/UtilizationProfile.ump:     * Returns the stored/packed obsolete offsets and the tracked obsolete offsets for the given file.  The tracked summary object returned can be used to test for obsolete offsets that are being added during cleaning by other threads participating in lazy migration.  The caller must call TrackedFileSummary.setAllowFlush(true) when cleaning is complete. This method performs eviction and is not synchronized.
base/umplific/UtilizationProfile.ump:					throw new ReturnBoolean(true);
base/umplific/UtilizationProfile.ump:					throw new ReturnBoolean(true);
base/umplific/UtilizationProfile.ump:					throw new ReturnBoolean(true);
base/umplific/UtilizationProfile.ump:			throw new ReturnBoolean(false);
base/umplific/UtilizationProfile.ump:	} catch (ReturnBoolean r) {
base/umplific/UtilizationProfile.ump:	    throw new ReturnBoolean(true);
base/umplific/UtilizationProfile.ump:	    throw new ReturnBoolean(true);
base/umplific/UtilizationProfile.ump:	    throw new ReturnBoolean(true);
base/umplific/UtilizationProfile.ump:	throw new ReturnBoolean(false);
base/umplific/FileProcessor.ump:     return; //throw new ReturnVoid();
base/umplific/FileProcessor.ump:    throw new ReturnObject(null);
base/umplific/FileProcessor.ump:    throw new ReturnObject(null);
base/umplific/FileProcessor.ump:    throw new ReturnObject( in );
base/umplific/FileProcessor.ump:  } catch (ReturnObject r) {
base/umplific/FileProcessor.ump:  * Check if the cloned IN is the same node as the root in tree. Return the real root if it is, null otherwise. If non-null is returned, the returned IN (the root) is latched -- caller is responsible for unlatching it.
base/umplific/FileProcessor.ump: 	    throw new ReturnObject(null);
base/umplific/FileProcessor.ump: 	    throw new ReturnObject(null);
base/umplific/FileProcessor.ump: 	    throw new ReturnObject(in);
base/umplific/Cleaner.ump:  * Returns a copy of the cleaned and processed files at the time a checkpoint starts. <p> If non-null is returned, the checkpoint should flush an extra level, and addCheckpointedFiles() should be called when the checkpoint is complete. </p>
base/umplific/ClassCatalog.ump:     * Return the class ID for the current version of the given class description. This is used for storing in serialization streams in place of a full class descriptor, since it is much more compact. To get back the ObjectStreamClass for a class ID, call {@link #getClassFormat(byte[])}. This function causes a new class ID to be assigned if the class description has changed.
base/umplific/BIN.ump:						throw new ReturnBoolean(false);
base/umplific/BIN.ump:					throw new ReturnBoolean(false);
base/umplific/BIN.ump:							throw new ReturnBoolean(child != null && child.isValidForDelete());
base/umplific/BIN.ump:									throw new ReturnBoolean(true);
base/umplific/BIN.ump:	} catch (ReturnBoolean r) {
base/umplific/BIN.ump://						throw new ReturnBoolean(false);
base/umplific/BIN.ump://					throw new ReturnBoolean(false);
base/umplific/BIN.ump://							throw new ReturnBoolean(child != null && child.isValidForDelete());
base/umplific/BIN.ump://									throw new ReturnBoolean(true);
base/umplific/IN.ump:				throw new ReturnBoolean(true);
base/umplific/IN.ump:	} catch (ReturnBoolean r) {
base/umplific/IN.ump:     * Returns whether any resident children are not LNs (are INs).
base/umplific/IN.ump:		throw new ReturnBoolean(true);
base/umplific/FileManager.ump:                throw new ReturnObject(fileHandle);
base/umplific/FileManager.ump:        } catch (ReturnObject r) {
base/umplific/FileManager.ump:    //   throw new ReturnObject(fileHandle);
base/umplific/SerialBinding.ump:     * Returns the class loader to be used during deserialization, or null if a default class loader should be used. The default implementation of this method returns null. <p> This method may be overriden to return a dynamically determined class loader. For example, <code>Thread.currentThread().getContextClassLoader()</code> could be called to use the context class loader for the curren thread. Or <code>getBaseClass().getClassLoader()</code> could be called to use the class loader for the base class, assuming that a base class has been specified. </p> <p> If this method returns null, a default class loader will be used as determined by the <code>java.io.ObjectInputStream.resolveClass</code> method. </p>
base/umplific/SyncedLockManager.ump:			throw new ReturnObject(attemptLockInternal(nodeId, locker, type, nonBlockingRequest, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnObject r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnObject(makeTimeoutMsgInternal(lockOrTxn, locker, nodeId, type, grantType, useLock, timeout,	start, now, database));
base/umplific/SyncedLockManager.ump:	} catch (ReturnObject r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnObject(		releaseAndFindNotifyTargetsInternal(nodeId, lock, locker, removeFromLocker, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnObject r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(isLockedInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnBoolean r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(isOwnerInternal(nodeId, locker, type, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnBoolean r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(isWaiterInternal(nodeId, locker, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnBoolean r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnInt(nWaitersInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnInt r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnInt(nOwnersInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnInt r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnObject(getWriteOwnerLockerInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnObject r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(validateOwnershipInternal(nodeId, locker, type, flushFromWaiters, mb, lockTableIndex));
base/umplific/SyncedLockManager.ump:	} catch (ReturnBoolean r) {
base/umplific/SyncedLockManager.ump:	throw new ReturnObject(attemptLockInternal(nodeId, locker, type, nonBlockingRequest, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(isLockedInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(isOwnerInternal(nodeId, locker, type, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(isWaiterInternal(nodeId, locker, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnInt(nWaitersInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnInt(nOwnersInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnObject(getWriteOwnerLockerInternal(nodeId, lockTableIndex));
base/umplific/SyncedLockManager.ump:	throw new ReturnBoolean(validateOwnershipInternal(nodeId, locker, type, flushFromWaiters, mb, lockTableIndex));
base/umplific/TxnManager.ump:     * Returns whether there are any active serializable transactions, excluding the transaction given (if non-null). This is intentionally returned without latching, since latching would not make the act of reading an integer more atomic than it already is.
base/umplific/FileSummaryLN.ump:     * Returns true if the given key for this LN is a String file number key. For the old version of the LN there will be a single record per file. If this is a version 0 log entry, the key is a string.  However, such an LN may be migrated by the cleaner, in which case the version will be 1 or greater [#13061].  In the latter case, we can distinguish a string key by: 1) If the key is not 8 bytes long, it has to be a string key. 2) If the key is 8 bytes long, but bytes[4] is ascii "0" to "9", then it must be a string key.  bytes[4] to bytes[7] are a sequence number that is the number of log entries counted.  For this number to be greater than 0x30000000, the binary value of 4 digits starting with ascii "0", over 400 million log entries would have to occur in a single file; this should never happen. Note that having to rely on method (2) is unlikely.  A string key will only be 8 bytes if the file number reach 8 decimal digits (10,000,000 to 99,999,999).  This is a very large file number and unlikely to have occurred using JE 1.7.1 or earlier. In summary, the only time the algorithm here could fail is if there were more than 400 million log entries per file, and more than 10 million were written with JE 1.7.1 or earlier.
base/umplific/Tree.ump:            throw new ReturnObject(wrl.doWork(root));
base/umplific/Tree.ump:        catch (ReturnObject r) {
base/umplific/Tree.ump:            throw new ReturnObject(wrl.doWork(root))
base/umplific/Tree.ump:        catch (ReturnObject r) {
base/umplific/Tree.ump:                return; //throw new ReturnVoid();
base/umplific/Tree.ump:                                throw new ReturnBoolean(searchDupTreeForDupCountLNParent(location, mainKey, childNode));
base/umplific/Tree.ump:                                        throw new ReturnBoolean(searchDupTreeForDBIN(location, dupKey, (DIN) childNode, ln,
base/umplific/Tree.ump:        } catch (ReturnBoolean r) {
base/umplific/Tree.ump:                throw new ReturnBoolean(true);
base/umplific/Tree.ump:                throw new ReturnBoolean(false);
base/umplific/Tree.ump:        } catch (ReturnBoolean r) {
base/umplific/Tree.ump:                        throw new ReturnObject(null);
base/umplific/Tree.ump:                        throw new ReturnObject(null);
base/umplific/Tree.ump:                            throw new ReturnObject(null);
base/umplific/Tree.ump:                        throw new ReturnObject((BIN) nextIN);
base/umplific/Tree.ump:                            throw new ReturnObject((BIN) ret);
base/umplific/Tree.ump:            catch (ReturnObject r) {
base/umplific/Tree.ump:     * @return - the Node that matches the criteria, if any. This is the nodethat is farthest down the tree with a match. Returns null if the root is null. Node is latched (unless it's null) and must be unlatched by the caller. Only IN's and BIN's are returned, not LN's. In a NORMAL search, It is the caller's responsibility to do the findEntry() call on the key and BIN to locate the entry that matches key. The return value node is latched upon return and it is the caller's responsibility to unlatch it.
base/umplific/Tree.ump:                    throw new ReturnObject(parent);
base/umplific/Tree.ump:                    throw new ReturnObject(parent);
base/umplific/Tree.ump:            throw new ReturnObject(parent);
base/umplific/Tree.ump:        } catch (ReturnObject r) {
base/umplific/Tree.ump:            throw new ReturnObject(rootIN);
base/umplific/Tree.ump:        catch (ReturnObject r) {
base/umplific/Tree.ump:                throw new ReturnBoolean(true);
base/umplific/Tree.ump:                    throw new ReturnBoolean(true);
base/umplific/Tree.ump:        } catch (ReturnBoolean r) {
base/umplific/Tree.ump:                        throw new ReturnBoolean(false);
base/umplific/Tree.ump:        } catch (ReturnBoolean r) {
base/umplific/Tree.ump:            Label715_1: throw new ReturnBoolean(rootIN.validateSubtreeBeforeDelete(index));
base/umplific/Tree.ump:        catch (ReturnBoolean r) {
base/umplific/PreloadLSNTreeWalker.ump:					throw new ReturnObject(null);
base/umplific/PreloadLSNTreeWalker.ump:			throw new ReturnObject(in.fetchTarget(inEntry.index));
base/umplific/PreloadLSNTreeWalker.ump:	} catch (ReturnObject r) {
base/umplific/PreloadLSNTreeWalker.ump:	    throw new ReturnObject(null);
base/umplific/PreloadLSNTreeWalker.ump:	throw new ReturnObject(in.fetchTarget(index));
base/umplific/Locker.ump:     * Returns whether this locker can share locks with the given locker. <p>All lockers share locks with a BuddyLocker whose buddy is this locker.  To support BuddyLocker when overriding this method, always return true if this implementation (super.sharesLocksWith(...)) returns true.</p>
base/umplific/MemoryBudget.ump:     * Returns Runtime.maxMemory(), accounting for a MacOS bug. May return Long.MAX_VALUE if there is no inherent limit. Used by unit tests as well as by this class.
CPBytes/originalFiles/Checkpointer.java:          throw new ReturnBoolean(true);
CPBytes/originalFiles/Checkpointer.java:          throw new ReturnBoolean(false);
CPBytes/logs/trace.log://           throw new ReturnBoolean(true);
CPBytes/logs/trace.log://           throw new ReturnBoolean(false);
CPBytes/ump_inner/CPBytes_Checkpointer_inner.ump:		          throw new ReturnBoolean(true);
CPBytes/ump_inner/CPBytes_Checkpointer_inner.ump:						      throw new ReturnBoolean(false);
CPBytes/ump_inner/CPBytes_Checkpointer_inner.ump:								  throw new ReturnBoolean(false); // add hook542
CPBytes/com/sleepycat/je/recovery/Checkpointer.java://           throw new ReturnBoolean(true);
CPBytes/com/sleepycat/je/recovery/Checkpointer.java://           throw new ReturnBoolean(false);
